{"ast":null,"code":"'use client';\n\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { useMemo, useRef, useState } from \"react\";\nimport { isEqual } from \"../../../../helpers/equal\";\nimport { clamp } from \"../../../../helpers/math\";\nimport { extractSliderAriaAttributes, getDraggingTypeByTargetDataset } from \"./helpers/html\";\nimport { offsetXToScaledValue, toPercent } from \"./helpers/math\";\nimport { determineSnapDirection, isMultipleValues, updateInternalStateByNativeChange, updateInternalStateValue } from \"./helpers/state\";\nexport const useSlider = _param => {\n  var {\n      step = 1,\n      min = 0,\n      max = 100,\n      value: valueProp,\n      multiple: multipleProp,\n      defaultValue = multipleProp ? [min, max] : min,\n      disabled,\n      getAriaLabel,\n      getAriaValueText,\n      onChange\n    } = _param,\n    restProps = _object_without_properties(_param, [\"step\", \"min\", \"max\", \"value\", \"multiple\", \"defaultValue\", \"disabled\", \"getAriaLabel\", \"getAriaValueText\", \"onChange\"]);\n  const isControlled = valueProp !== undefined;\n  const [localValue, setValue] = useState(defaultValue);\n  const value = useMemo(() => {\n    const resolvedValue = isControlled ? valueProp : localValue;\n    return Array.isArray(resolvedValue) ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)] : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n  const [startValue, endValue] = value;\n  const multiple = multipleProp && endValue !== null;\n  const gesture = useRef({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0\n  }).current;\n  const thumbsContainerRef = useRef(null);\n  const thumbStartInputRef = useRef(null);\n  const thumbEndInputRef = useRef(null);\n  const changeValue = (nextValue, event) => {\n    if (disabled || isEqual(nextValue[0], nextValue[1])) {\n      return;\n    }\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n  const handlePointerStart = event => {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n    const {\n      left: nextContainerX,\n      width: nextContainerWidth\n    } = thumbsContainerRef.current.getBoundingClientRect();\n    if (!(event.originalEvent.target instanceof HTMLElement)) {\n      return;\n    }\n    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n    const nextStartX = event.startX - nextContainerX;\n    const nextValue = offsetXToScaledValue(nextStartX, nextContainerWidth, min, max, step);\n    const nextDragging = determineSnapDirection(value, nextValue, foundDraggingType);\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n    const updatedInternalStateValue = updateInternalStateValue(value, nextValue, min, max, nextDragging);\n    const [nextStartValue, nextEndValue] = updatedInternalStateValue;\n    if (thumbStartInputRef.current && (foundDraggingType === 'start' || nextStartValue !== startValue && nextEndValue === endValue)) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (thumbEndInputRef.current && (foundDraggingType === 'end' || nextEndValue !== endValue && nextStartValue === startValue)) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n    changeValue(updatedInternalStateValue, event);\n    event.originalEvent.stopPropagation();\n  };\n  const handlePointerMove = event => {\n    const {\n      startX,\n      containerWidth,\n      dragging\n    } = gesture;\n    const {\n      shiftX = 0\n    } = event;\n    const nextStartX = startX + shiftX;\n    const nextValue = offsetXToScaledValue(nextStartX, containerWidth, min, max, step);\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n  const handlePointerEnd = event => {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n  };\n  const handleChangeByNativeInput = event => {\n    changeValue(updateInternalStateByNativeChange(value, Number(event.target.value), getDraggingTypeByTargetDataset(event.target)), event);\n  };\n  const _extractSliderAriaAttributes = extractSliderAriaAttributes(restProps),\n    {\n      aria\n    } = _extractSliderAriaAttributes,\n    restPropsWithoutArea = _object_without_properties(_extractSliderAriaAttributes, [\"aria\"]);\n  const getInputProps = isEndInput => {\n    const index = isEndInput ? 1 : 0;\n    return {\n      'data-type': isEndInput ? 'end' : 'start',\n      step,\n      min,\n      value: isEndInput && multiple ? endValue : startValue,\n      max: !isEndInput && multiple ? endValue : max,\n      disabled,\n      'aria-label': getAriaLabel ? getAriaLabel(index) : aria.ariaLabel,\n      'aria-valuetext': getAriaValueText ? getAriaValueText(startValue, index) : aria.ariaValueText,\n      'aria-labelledby': aria.ariaLabelledBy,\n      onChange: handleChangeByNativeInput\n    };\n  };\n  const getStepsCoordinates = () => {\n    if (step === 1) {\n      return undefined;\n    }\n    const steps = [];\n    const stepsCount = Math.floor((max - min) / step);\n    for (let i = 0; i <= stepsCount; i += 1) {\n      const stepValue = min + i * step;\n      const isPassed = multiple ? stepValue >= startValue && stepValue <= endValue : stepValue <= startValue;\n      steps.push({\n        isPassed,\n        XCoordinate: toPercent(stepValue, min, max)\n      });\n    }\n    return steps;\n  };\n  return {\n    steps: getStepsCoordinates(),\n    multiple,\n    containerProps: restPropsWithoutArea,\n    startValueInPercent: toPercent(startValue, min, max),\n    endReversedValueInPercent: multiple ? toPercent(endValue, min, max) : 0,\n    thumbsContainerRef,\n    thumbStartInputRef,\n    thumbEndInputRef,\n    handlePointerStart,\n    handlePointerMove,\n    handlePointerEnd,\n    getInputProps\n  };\n};","map":{"version":3,"names":["useMemo","useRef","useState","isEqual","clamp","extractSliderAriaAttributes","getDraggingTypeByTargetDataset","offsetXToScaledValue","toPercent","determineSnapDirection","isMultipleValues","updateInternalStateByNativeChange","updateInternalStateValue","useSlider","_param","step","min","max","value","valueProp","multiple","multipleProp","defaultValue","disabled","getAriaLabel","getAriaValueText","onChange","restProps","_object_without_properties","isControlled","undefined","localValue","setValue","resolvedValue","Array","isArray","startValue","endValue","gesture","dragging","startX","containerWidth","current","thumbsContainerRef","thumbStartInputRef","thumbEndInputRef","changeValue","nextValue","event","handlePointerStart","left","nextContainerX","width","nextContainerWidth","getBoundingClientRect","originalEvent","target","HTMLElement","foundDraggingType","nextStartX","nextDragging","updatedInternalStateValue","nextStartValue","nextEndValue","focus","preventDefault","stopPropagation","handlePointerMove","shiftX","handlePointerEnd","handleChangeByNativeInput","Number","_extractSliderAriaAttributes","aria","restPropsWithoutArea","getInputProps","isEndInput","index","ariaLabel","ariaValueText","ariaLabelledBy","getStepsCoordinates","steps","stepsCount","Math","floor","i","stepValue","isPassed","push","XCoordinate","containerProps","startValueInPercent","endReversedValueInPercent"],"sources":["/home/dmitry/Projects/MEPhI/MEPhI360/TGUI-Example/node_modules/@telegram-apps/telegram-ui/src/components/Form/Slider/hooks/useSlider.ts"],"sourcesContent":["'use client';\n\nimport { ChangeEvent, useMemo, useRef, useState } from 'react';\n\nimport { isEqual } from 'helpers/equal';\nimport { clamp } from 'helpers/math';\n\nimport { SliderProps } from 'components/Form/Slider/Slider';\nimport type { TouchEvent } from 'components/Service/Touch/Touch';\nimport { extractSliderAriaAttributes, getDraggingTypeByTargetDataset } from './helpers/html';\nimport { offsetXToScaledValue, toPercent } from './helpers/math';\nimport {\n  determineSnapDirection,\n  isMultipleValues,\n  updateInternalStateByNativeChange,\n  updateInternalStateValue,\n} from './helpers/state';\nimport { InternalGestureRef, InternalValueState, Step } from './types';\n\nexport const useSlider = ({\n  step = 1,\n  min = 0,\n  max = 100,\n  value: valueProp,\n  multiple: multipleProp,\n  defaultValue = multipleProp ? [min, max] : min,\n  disabled,\n  getAriaLabel,\n  getAriaValueText,\n  onChange,\n  ...restProps\n}: SliderProps) => {\n  const isControlled = valueProp !== undefined;\n  const [localValue, setValue] = useState(defaultValue);\n\n  const value = useMemo<InternalValueState>(() => {\n    const resolvedValue = isControlled ? valueProp : localValue;\n\n    return Array.isArray(resolvedValue)\n      ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)]\n      : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n\n  const [startValue, endValue] = value;\n  const multiple = multipleProp && endValue !== null;\n\n  const gesture = useRef<InternalGestureRef>({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0,\n  }).current;\n\n  const thumbsContainerRef = useRef<HTMLDivElement>(null);\n  const thumbStartInputRef = useRef<HTMLInputElement>(null);\n  const thumbEndInputRef = useRef<HTMLInputElement>(null);\n\n  const changeValue = (nextValue: InternalValueState, event: TouchEvent | ChangeEvent) => {\n    if (disabled || isEqual(nextValue[0], nextValue[1])) {\n      return;\n    }\n\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n\n  const handlePointerStart = (event: TouchEvent) => {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n\n    const { left: nextContainerX, width: nextContainerWidth } =\n      thumbsContainerRef.current.getBoundingClientRect();\n\n    if (!(event.originalEvent.target instanceof HTMLElement)) {\n      return;\n    }\n\n    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n    const nextStartX = event.startX - nextContainerX;\n    const nextValue = offsetXToScaledValue(nextStartX, nextContainerWidth, min, max, step);\n    const nextDragging = determineSnapDirection(value, nextValue, foundDraggingType);\n\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n\n    const updatedInternalStateValue = updateInternalStateValue(\n      value,\n      nextValue,\n      min,\n      max,\n      nextDragging,\n    );\n\n    const [nextStartValue, nextEndValue] = updatedInternalStateValue;\n    if (\n      thumbStartInputRef.current &&\n      (foundDraggingType === 'start' || (nextStartValue !== startValue && nextEndValue === endValue))\n    ) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (\n      thumbEndInputRef.current &&\n      (foundDraggingType === 'end' || (nextEndValue !== endValue && nextStartValue === startValue))\n    ) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n\n    changeValue(updatedInternalStateValue, event);\n    event.originalEvent.stopPropagation();\n  };\n\n  const handlePointerMove = (event: TouchEvent) => {\n    const { startX, containerWidth, dragging } = gesture;\n\n    const { shiftX = 0 } = event;\n    const nextStartX = startX + shiftX;\n    const nextValue = offsetXToScaledValue(nextStartX, containerWidth, min, max, step);\n\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const handlePointerEnd = (event: TouchEvent) => {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n  };\n\n  const handleChangeByNativeInput = (event: ChangeEvent<HTMLInputElement>) => {\n    changeValue(\n      updateInternalStateByNativeChange(\n        value,\n        Number(event.target.value),\n        getDraggingTypeByTargetDataset(event.target),\n      ),\n      event,\n    );\n  };\n\n  const { aria, ...restPropsWithoutArea } = extractSliderAriaAttributes(restProps);\n  const getInputProps = (isEndInput: boolean) => {\n    const index = isEndInput ? 1 : 0;\n    return {\n      'data-type': isEndInput ? 'end' : 'start',\n      step,\n      min,\n      value: isEndInput && multiple ? endValue : startValue,\n      max: !isEndInput && multiple ? endValue : max,\n      disabled,\n      'aria-label': getAriaLabel ? getAriaLabel(index) : aria.ariaLabel,\n      'aria-valuetext': getAriaValueText ? getAriaValueText(startValue, index) : aria.ariaValueText,\n      'aria-labelledby': aria.ariaLabelledBy,\n      onChange: handleChangeByNativeInput,\n    };\n  };\n\n  const getStepsCoordinates = () => {\n    if (step === 1) {\n      return undefined;\n    }\n\n    const steps: Step[] = [];\n    const stepsCount = Math.floor((max - min) / step);\n\n    for (let i = 0; i <= stepsCount; i += 1) {\n      const stepValue = min + i * step;\n\n      const isPassed = multiple\n        ? stepValue >= startValue && stepValue <= endValue\n        : stepValue <= startValue;\n\n      steps.push({\n        isPassed,\n        XCoordinate: toPercent(stepValue, min, max),\n      });\n    }\n\n    return steps;\n  };\n\n  return {\n    steps: getStepsCoordinates(),\n    multiple,\n    containerProps: restPropsWithoutArea,\n    startValueInPercent: toPercent(startValue, min, max),\n    endReversedValueInPercent: multiple ? toPercent(endValue, min, max) : 0,\n    thumbsContainerRef,\n    thumbStartInputRef,\n    thumbEndInputRef,\n    handlePointerStart,\n    handlePointerMove,\n    handlePointerEnd,\n    getInputProps,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}