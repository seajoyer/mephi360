{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-use-before-define */'use client';\n\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useMemo, useRef } from \"react\";\nimport { useEnhancedEffect } from \"../../../hooks/useEnhancedEffect\";\nimport { useEventListener } from \"../../../hooks/useEventListener\";\nimport { coordX, coordY, getSupportedEvents, initGesture, touchEnabled } from \"./helpers/touch\";\n/**\n * This component is copied from the VKUI library for convenient handling of pointer events\n * https://github.com/VKCOM/VKUI/blob/master/packages/vkui/src/components/Touch/Touch.tsx#L65\n */\nexport const Touch = _param => {\n  var {\n      Component = 'div',\n      onStart,\n      onStartX,\n      onStartY,\n      onMove: _onMove,\n      onMoveX,\n      onMoveY,\n      onLeave,\n      onEnter,\n      onEnd: _onEnd,\n      onEndX,\n      onEndY,\n      onClickCapture,\n      usePointerHover,\n      slideThreshold = 5,\n      useCapture = false,\n      noSlideClick = false,\n      stopPropagation = false\n    } = _param,\n    restProps = _object_without_properties(_param, [\"Component\", \"onStart\", \"onStartX\", \"onStartY\", \"onMove\", \"onMoveX\", \"onMoveY\", \"onLeave\", \"onEnter\", \"onEnd\", \"onEndX\", \"onEndY\", \"onClickCapture\", \"usePointerHover\", \"slideThreshold\", \"useCapture\", \"noSlideClick\", \"stopPropagation\"]);\n  const events = useMemo(getSupportedEvents, []);\n  const didSlide = useRef(false);\n  const gesture = useRef(null);\n  const handle = (e, handlers) => {\n    stopPropagation && e.stopPropagation();\n    handlers.forEach(cb => {\n      var _gesture_current_startT, _gesture_current;\n      var _gesture_current_startT_getTime;\n      const duration = Date.now() - ((_gesture_current_startT_getTime = (_gesture_current = gesture.current) === null || _gesture_current === void 0 ? void 0 : (_gesture_current_startT = _gesture_current.startT) === null || _gesture_current_startT === void 0 ? void 0 : _gesture_current_startT.getTime()) !== null && _gesture_current_startT_getTime !== void 0 ? _gesture_current_startT_getTime : 0);\n      cb && cb(_object_spread_props(_object_spread({}, gesture.current), {\n        duration,\n        originalEvent: e\n      }));\n    });\n  };\n  const listenerParams = {\n    capture: useCapture,\n    passive: false\n  };\n  const listeners = [useEventListener(events[1], onMove, listenerParams), useEventListener(events[2], onEnd, listenerParams), useEventListener(events[3], onEnd, listenerParams)];\n  const subscribe = el => {\n    if (!el) {\n      return;\n    }\n    listeners.forEach(l => l.add(el));\n  };\n  const unsubscribe = () => {\n    listeners.forEach(l => l.remove());\n  };\n  const enterHandler = useEventListener(usePointerHover ? 'pointerenter' : 'mouseenter', onEnter);\n  const leaveHandler = useEventListener(usePointerHover ? 'pointerleave' : 'mouseleave', onLeave);\n  const startHandler = useEventListener(events[0], e => {\n    gesture.current = initGesture(coordX(e), coordY(e));\n    handle(e, [onStart, onStartX, onStartY]);\n    subscribe(touchEnabled() ?\n    // see: #235, #1968, https://stackoverflow.com/a/45760014\n    e.target :\n    // if the pointer goes outside the container.\n    // Can be fixed by PointerEvents' setPointerCapture later\n    window.document);\n  }, {\n    capture: useCapture,\n    passive: false\n  });\n  const containerRef = useRef();\n  useEnhancedEffect(() => {\n    const el = containerRef.current;\n    if (el) {\n      enterHandler.add(el);\n      leaveHandler.add(el);\n      startHandler.add(el);\n    }\n  }, [Component]);\n  function onMove(e) {\n    var _gesture_current;\n    const {\n      isPressed,\n      isX,\n      isY,\n      startX = 0,\n      startY = 0\n    } = (_gesture_current = gesture.current) !== null && _gesture_current !== void 0 ? _gesture_current : {};\n    if (isPressed) {\n      var _gesture_current1;\n      const clientX = coordX(e);\n      const clientY = coordY(e);\n      // Offsets\n      const shiftX = clientX - startX;\n      const shiftY = clientY - startY;\n      // Absolute offset values\n      const shiftXAbs = Math.abs(shiftX);\n      const shiftYAbs = Math.abs(shiftY);\n      // If determining multitouch, interrupt the gesture\n      if (!!e.touches && e.touches.length > 1) {\n        onEnd(e);\n        return;\n      }\n      // If we haven't determined yet\n      if (!isX && !isY) {\n        const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;\n        const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;\n        const willBeSlidedX = willBeX && (!!onMoveX || !!_onMove);\n        const willBeSlidedY = willBeY && (!!onMoveY || !!_onMove);\n        if (gesture.current) {\n          Object.assign(gesture.current, {\n            isY: willBeY,\n            isX: willBeX,\n            isSlideX: willBeSlidedX,\n            isSlideY: willBeSlidedY,\n            isSlide: willBeSlidedX || willBeSlidedY\n          });\n        }\n      }\n      if ((_gesture_current1 = gesture.current) === null || _gesture_current1 === void 0 ? void 0 : _gesture_current1.isSlide) {\n        Object.assign(gesture.current, {\n          clientX,\n          clientY,\n          shiftX,\n          shiftY,\n          shiftXAbs,\n          shiftYAbs\n        });\n        handle(e, [_onMove, gesture.current.isSlideX && onMoveX, gesture.current.isSlideY && onMoveY]);\n      }\n    }\n  }\n  function onEnd(e) {\n    var _gesture_current;\n    const {\n      isPressed,\n      isSlide,\n      isSlideX,\n      isSlideY\n    } = (_gesture_current = gesture.current) !== null && _gesture_current !== void 0 ? _gesture_current : {};\n    if (isPressed) {\n      handle(e, [_onEnd, isSlideY && onEndY, isSlideX && onEndX]);\n    }\n    const isTouchEnabled = touchEnabled();\n    if (isTouchEnabled && isSlide) {\n      // If it's a touch device and touchmove was detected,\n      // the click event won't be triggered\n      didSlide.current = false;\n    } else {\n      didSlide.current = Boolean(isSlide);\n    }\n    gesture.current = {};\n    // If it was a touch event, simulate hover cancellation\n    if (isTouchEnabled) {\n      onLeave && onLeave(e);\n    }\n    unsubscribe();\n  }\n  /**\n  * Dragstart event handler\n  * Cancels the native browser behavior for nested links and images\n  */\n  const onDragStart = e => {\n    const target = e.target;\n    if (target.tagName === 'A' || target.tagName === 'IMG') {\n      e.preventDefault();\n    }\n  };\n  /**\n  * Click event handler for the component\n  * Cancels the transition through the nested link if a swipe was detected\n  */\n  const postGestureClick = e => {\n    if (!didSlide.current) {\n      onClickCapture && onClickCapture(e);\n      return;\n    }\n    if (noSlideClick) {\n      e.stopPropagation();\n      e.preventDefault();\n    } else {\n      onClickCapture && onClickCapture(e);\n    }\n    didSlide.current = false;\n  };\n  return /*#__PURE__*/_jsx(Component, _object_spread_props(_object_spread({}, restProps), {\n    onDragStart: onDragStart,\n    onClickCapture: postGestureClick,\n    ref: containerRef\n  }));\n};","map":{"version":3,"names":["useMemo","useRef","useEnhancedEffect","useEventListener","coordX","coordY","getSupportedEvents","initGesture","touchEnabled","Touch","_param","Component","onStart","onStartX","onStartY","onMove","_onMove","onMoveX","onMoveY","onLeave","onEnter","onEnd","_onEnd","onEndX","onEndY","onClickCapture","usePointerHover","slideThreshold","useCapture","noSlideClick","stopPropagation","restProps","_object_without_properties","events","didSlide","gesture","handle","e","handlers","forEach","cb","_gesture_current_startT","_gesture_current","_gesture_current_startT_getTime","duration","Date","now","current","startT","getTime","_object_spread_props","_object_spread","originalEvent","listenerParams","capture","passive","listeners","subscribe","el","l","add","unsubscribe","remove","enterHandler","leaveHandler","startHandler","target","window","document","containerRef","isPressed","isX","isY","startX","startY","_gesture_current1","clientX","clientY","shiftX","shiftY","shiftXAbs","Math","abs","shiftYAbs","touches","length","willBeX","willBeY","willBeSlidedX","willBeSlidedY","Object","assign","isSlideX","isSlideY","isSlide","isTouchEnabled","Boolean","onDragStart","tagName","preventDefault","postGestureClick","_jsx","ref"],"sources":["/home/dmitry/Projects/MEPhI/MEPhI360/app/node_modules/@telegram-apps/telegram-ui/src/components/Service/Touch/Touch.tsx"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\n\n'use client';\n\nimport { AllHTMLAttributes, DragEvent, ElementType, MouseEvent as ReactMouseEvent, useMemo, useRef } from 'react';\n\nimport { useEnhancedEffect } from 'hooks/useEnhancedEffect';\nimport { useEventListener } from 'hooks/useEventListener';\n\nimport { coordX, coordY, getSupportedEvents, initGesture, touchEnabled } from './helpers/touch';\nimport { CustomTouchEvent, Gesture } from './helpers/types';\n\nexport interface TouchProps extends AllHTMLAttributes<HTMLElement> {\n  usePointerHover?: boolean;\n  useCapture?: boolean;\n  slideThreshold?: number;\n  noSlideClick?: boolean;\n  onEnter?: HoverHandler;\n  onLeave?: HoverHandler;\n  onStart?: TouchEventHandler;\n  onStartX?: TouchEventHandler;\n  onStartY?: TouchEventHandler;\n  onMove?: TouchEventHandler;\n  onMoveX?: TouchEventHandler;\n  onMoveY?: TouchEventHandler;\n  onEnd?: TouchEventHandler;\n  onEndX?: TouchEventHandler;\n  onEndY?: TouchEventHandler;\n  stopPropagation?: boolean;\n  Component?: ElementType;\n}\n\nexport interface TouchEvent extends Gesture {\n  originalEvent: CustomTouchEvent;\n}\n\ntype HoverHandler = (outputEvent: MouseEvent) => void;\nexport type TouchEventHandler = (e: TouchEvent) => void;\nexport type ClickHandler = (e: ReactMouseEvent<HTMLElement>) => void;\nexport type DragHandler = (e: DragEvent<HTMLElement>) => void;\n\n/**\n * This component is copied from the VKUI library for convenient handling of pointer events\n * https://github.com/VKCOM/VKUI/blob/master/packages/vkui/src/components/Touch/Touch.tsx#L65\n */\nexport const Touch = ({\n  Component = 'div',\n  onStart,\n  onStartX,\n  onStartY,\n  onMove: _onMove,\n  onMoveX,\n  onMoveY,\n  onLeave,\n  onEnter,\n  onEnd: _onEnd,\n  onEndX,\n  onEndY,\n  onClickCapture,\n  usePointerHover,\n  slideThreshold = 5,\n  useCapture = false,\n  noSlideClick = false,\n  stopPropagation = false,\n  ...restProps\n}: TouchProps) => {\n  const events = useMemo(getSupportedEvents, []);\n  const didSlide = useRef(false);\n  const gesture = useRef<Partial<Gesture> | null>(null);\n\n  const handle = (e: CustomTouchEvent, handlers: Array<TouchEventHandler | undefined | false>) => {\n    stopPropagation && e.stopPropagation();\n    handlers.forEach((cb) => {\n      const duration = Date.now() - (gesture.current?.startT?.getTime() ?? 0);\n      cb && cb({ ...(gesture.current as Gesture), duration, originalEvent: e });\n    });\n  };\n\n  const listenerParams = { capture: useCapture, passive: false };\n  const listeners = [\n    useEventListener(events[1], onMove, listenerParams),\n    useEventListener(events[2], onEnd, listenerParams),\n    useEventListener(events[3], onEnd, listenerParams),\n  ];\n\n  const subscribe = (el: HTMLElement | Document | null | undefined) => {\n    if (!el) {\n      return;\n    }\n\n    listeners.forEach((l) => l.add(el));\n  };\n\n  const unsubscribe = () => {\n    listeners.forEach((l) => l.remove());\n  };\n\n  const enterHandler = useEventListener(usePointerHover ? 'pointerenter' : 'mouseenter', onEnter);\n  const leaveHandler = useEventListener(usePointerHover ? 'pointerleave' : 'mouseleave', onLeave);\n  const startHandler = useEventListener(\n    events[0],\n    (e: CustomTouchEvent) => {\n      gesture.current = initGesture(coordX(e), coordY(e));\n\n      handle(e, [onStart, onStartX, onStartY]);\n      subscribe(\n        touchEnabled()\n          ? // Touch events fire on the initial target and won't bubble if it's removed\n        // see: #235, #1968, https://stackoverflow.com/a/45760014\n          (e.target as HTMLElement)\n          : // Mouse events fire on the element under the pointer, so we lose move / end\n        // if the pointer goes outside the container.\n        // Can be fixed by PointerEvents' setPointerCapture later\n          window.document,\n      );\n    },\n    { capture: useCapture, passive: false },\n  );\n  const containerRef = useRef();\n\n  useEnhancedEffect(() => {\n    const el = containerRef.current;\n    if (el) {\n      enterHandler.add(el);\n      leaveHandler.add(el);\n      startHandler.add(el);\n    }\n  }, [Component]);\n\n  function onMove(e: CustomTouchEvent) {\n    const { isPressed, isX, isY, startX = 0, startY = 0 } = gesture.current ?? {};\n\n    if (isPressed) {\n      const clientX = coordX(e);\n      const clientY = coordY(e);\n\n      // Offsets\n      const shiftX = clientX - startX;\n      const shiftY = clientY - startY;\n\n      // Absolute offset values\n      const shiftXAbs = Math.abs(shiftX);\n      const shiftYAbs = Math.abs(shiftY);\n\n      // If determining multitouch, interrupt the gesture\n      if (!!e.touches && e.touches.length > 1) {\n        onEnd(e);\n        return;\n      }\n\n      // If we haven't determined yet\n      if (!isX && !isY) {\n        const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;\n        const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;\n        const willBeSlidedX = willBeX && (!!onMoveX || !!_onMove);\n        const willBeSlidedY = willBeY && (!!onMoveY || !!_onMove);\n\n        if (gesture.current) {\n          Object.assign(gesture.current, {\n            isY: willBeY,\n            isX: willBeX,\n            isSlideX: willBeSlidedX,\n            isSlideY: willBeSlidedY,\n            isSlide: willBeSlidedX || willBeSlidedY,\n          });\n        }\n      }\n\n      if (gesture.current?.isSlide) {\n        Object.assign(gesture.current, {\n          clientX,\n          clientY,\n          shiftX,\n          shiftY,\n          shiftXAbs,\n          shiftYAbs,\n        });\n\n        handle(e, [\n          _onMove,\n          gesture.current.isSlideX && onMoveX,\n          gesture.current.isSlideY && onMoveY,\n        ]);\n      }\n    }\n  }\n\n  function onEnd(e: CustomTouchEvent) {\n    const { isPressed, isSlide, isSlideX, isSlideY } = gesture.current ?? {};\n\n    if (isPressed) {\n      handle(e, [_onEnd, isSlideY && onEndY, isSlideX && onEndX]);\n    }\n\n    const isTouchEnabled = touchEnabled();\n\n    if (isTouchEnabled && isSlide) {\n      // If it's a touch device and touchmove was detected,\n      // the click event won't be triggered\n      didSlide.current = false;\n    } else {\n      didSlide.current = Boolean(isSlide);\n    }\n    gesture.current = {};\n\n    // If it was a touch event, simulate hover cancellation\n    if (isTouchEnabled) {\n      onLeave && onLeave(e);\n    }\n\n    unsubscribe();\n  }\n\n  /**\n   * Dragstart event handler\n   * Cancels the native browser behavior for nested links and images\n   */\n  const onDragStart = (e: DragEvent<HTMLElement>) => {\n    const target = e.target as HTMLElement;\n    if (target.tagName === 'A' || target.tagName === 'IMG') {\n      e.preventDefault();\n    }\n  };\n\n  /**\n   * Click event handler for the component\n   * Cancels the transition through the nested link if a swipe was detected\n   */\n  const postGestureClick: typeof onClickCapture = (e) => {\n    if (!didSlide.current) {\n      onClickCapture && onClickCapture(e);\n      return;\n    }\n\n    if (noSlideClick) {\n      e.stopPropagation();\n      e.preventDefault();\n    } else {\n      onClickCapture && onClickCapture(e);\n    }\n\n    didSlide.current = false;\n  };\n\n  return (\n    <Component\n      {...restProps}\n      onDragStart={onDragStart}\n      onClickCapture={postGestureClick}\n      ref={containerRef}\n    />\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}