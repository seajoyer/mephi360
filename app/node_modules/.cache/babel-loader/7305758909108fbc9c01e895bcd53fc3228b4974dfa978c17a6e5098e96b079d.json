{"ast":null,"code":"import { clamp } from \"../../../../../helpers/math\";\nexport const updateInternalStateValue = (currentState, newValue, minValue, maxValue, draggingType) => {\n  const [currentStartValue, currentEndValue] = currentState;\n  if (currentEndValue === null) {\n    return [clamp(newValue, minValue, maxValue), null];\n  }\n  switch (draggingType) {\n    case 'start':\n      return newValue > currentEndValue ? [currentEndValue, currentEndValue] : [clamp(newValue, minValue, maxValue), currentEndValue];\n    case 'end':\n      return newValue < currentStartValue ? [currentStartValue, currentStartValue] : [currentStartValue, clamp(newValue, minValue, maxValue)];\n    case null:\n    default:\n      return currentState;\n  }\n};\nexport const updateInternalStateByNativeChange = (currentState, newValue, draggingType) => {\n  const [currentStartValue, currentEndValue] = currentState;\n  switch (draggingType) {\n    case 'start':\n      return [newValue, currentEndValue];\n    case 'end':\n      return [currentStartValue, newValue];\n    case null:\n    default:\n      return currentState;\n  }\n};\nexport const isMultipleValues = value => {\n  return value[1] !== null;\n};\nconst MINIMUM_DIFFERENCE_BETWEEN_START_AND_END = 0.1;\nexport const determineSnapDirection = (currentValues, newValue, draggingType) => {\n  if (draggingType === 'start' || draggingType === 'end') {\n    return draggingType;\n  }\n  const [startRaw, endRaw] = currentValues;\n  const start = endRaw !== null ? startRaw - MINIMUM_DIFFERENCE_BETWEEN_START_AND_END : startRaw;\n  const end = endRaw !== null ? endRaw + MINIMUM_DIFFERENCE_BETWEEN_START_AND_END : 0;\n  return Math.abs(start - newValue) <= Math.abs(end - newValue) ? 'start' : 'end';\n};","map":{"version":3,"names":["clamp","updateInternalStateValue","currentState","newValue","minValue","maxValue","draggingType","currentStartValue","currentEndValue","updateInternalStateByNativeChange","isMultipleValues","value","MINIMUM_DIFFERENCE_BETWEEN_START_AND_END","determineSnapDirection","currentValues","startRaw","endRaw","start","end","Math","abs"],"sources":["/home/dmitry/Projects/MEPhI/MEPhI360/TGUI-Example/node_modules/@telegram-apps/telegram-ui/src/components/Form/Slider/hooks/helpers/state.ts"],"sourcesContent":["import { clamp } from 'helpers/math';\n\nimport type { InternalDraggingType, InternalValueState } from '../types';\n\nexport const updateInternalStateValue = (\n  currentState: InternalValueState,\n  newValue: number,\n  minValue: number,\n  maxValue: number,\n  draggingType: InternalDraggingType | null,\n): InternalValueState => {\n  const [currentStartValue, currentEndValue] = currentState;\n\n  if (currentEndValue === null) {\n    return [clamp(newValue, minValue, maxValue), null];\n  }\n\n  switch (draggingType) {\n    case 'start':\n      return newValue > currentEndValue\n        ? [currentEndValue, currentEndValue]\n        : [clamp(newValue, minValue, maxValue), currentEndValue];\n    case 'end':\n      return newValue < currentStartValue\n        ? [currentStartValue, currentStartValue]\n        : [currentStartValue, clamp(newValue, minValue, maxValue)];\n    case null:\n    default:\n      return currentState;\n  }\n};\n\nexport const updateInternalStateByNativeChange = (\n  currentState: InternalValueState,\n  newValue: number,\n  draggingType: InternalDraggingType | null,\n): InternalValueState => {\n  const [currentStartValue, currentEndValue] = currentState;\n  switch (draggingType) {\n    case 'start':\n      return [newValue, currentEndValue];\n    case 'end':\n      return [currentStartValue, newValue];\n    case null:\n    default:\n      return currentState;\n  }\n};\n\nexport const isMultipleValues = (value: InternalValueState): value is [number, number] => {\n  return value[1] !== null;\n};\n\nconst MINIMUM_DIFFERENCE_BETWEEN_START_AND_END = 0.1;\n\nexport const determineSnapDirection = (\n  currentValues: InternalValueState,\n  newValue: number,\n  draggingType: InternalDraggingType | null,\n): InternalDraggingType | null => {\n  if (draggingType === 'start' || draggingType === 'end') {\n    return draggingType;\n  }\n\n  const [startRaw, endRaw] = currentValues;\n  const start = endRaw !== null ? startRaw - MINIMUM_DIFFERENCE_BETWEEN_START_AND_END : startRaw;\n  const end = endRaw !== null ? endRaw + MINIMUM_DIFFERENCE_BETWEEN_START_AND_END : 0;\n\n  return Math.abs(start - newValue) <= Math.abs(end - newValue) ? 'start' : 'end';\n};\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ;AAItB,OAAO,MAAMC,wBAAA,GAA2BA,CACtCC,YAAA,EACAC,QAAA,EACAC,QAAA,EACAC,QAAA,EACAC,YAAA;EAEA,MAAM,CAACC,iBAAA,EAAmBC,eAAA,CAAgB,GAAGN,YAAA;EAE7C,IAAIM,eAAA,KAAoB,MAAM;IAC5B,OAAO,CAACR,KAAA,CAAMG,QAAA,EAAUC,QAAA,EAAUC,QAAA,GAAW,KAAK;EACpD;EAEA,QAAQC,YAAA;IACN,KAAK;MACH,OAAOH,QAAA,GAAWK,eAAA,GACd,CAACA,eAAA,EAAiBA,eAAA,CAAgB,GAClC,CAACR,KAAA,CAAMG,QAAA,EAAUC,QAAA,EAAUC,QAAA,GAAWG,eAAA,CAAgB;IAC5D,KAAK;MACH,OAAOL,QAAA,GAAWI,iBAAA,GACd,CAACA,iBAAA,EAAmBA,iBAAA,CAAkB,GACtC,CAACA,iBAAA,EAAmBP,KAAA,CAAMG,QAAA,EAAUC,QAAA,EAAUC,QAAA,EAAU;IAC9D,KAAK;IACL;MACE,OAAOH,YAAA;EACX;AACF;AAEA,OAAO,MAAMO,iCAAA,GAAoCA,CAC/CP,YAAA,EACAC,QAAA,EACAG,YAAA;EAEA,MAAM,CAACC,iBAAA,EAAmBC,eAAA,CAAgB,GAAGN,YAAA;EAC7C,QAAQI,YAAA;IACN,KAAK;MACH,OAAO,CAACH,QAAA,EAAUK,eAAA,CAAgB;IACpC,KAAK;MACH,OAAO,CAACD,iBAAA,EAAmBJ,QAAA,CAAS;IACtC,KAAK;IACL;MACE,OAAOD,YAAA;EACX;AACF;AAEA,OAAO,MAAMQ,gBAAA,GAAoBC,KAAA;EAC/B,OAAOA,KAAK,CAAC,EAAE,KAAK;AACtB;AAEA,MAAMC,wCAAA,GAA2C;AAEjD,OAAO,MAAMC,sBAAA,GAAyBA,CACpCC,aAAA,EACAX,QAAA,EACAG,YAAA;EAEA,IAAIA,YAAA,KAAiB,WAAWA,YAAA,KAAiB,OAAO;IACtD,OAAOA,YAAA;EACT;EAEA,MAAM,CAACS,QAAA,EAAUC,MAAA,CAAO,GAAGF,aAAA;EAC3B,MAAMG,KAAA,GAAQD,MAAA,KAAW,OAAOD,QAAA,GAAWH,wCAAA,GAA2CG,QAAA;EACtF,MAAMG,GAAA,GAAMF,MAAA,KAAW,OAAOA,MAAA,GAASJ,wCAAA,GAA2C;EAElF,OAAOO,IAAA,CAAKC,GAAG,CAACH,KAAA,GAAQd,QAAA,KAAagB,IAAA,CAAKC,GAAG,CAACF,GAAA,GAAMf,QAAA,IAAY,UAAU;AAC5E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}