{"ast":null,"code":"'use client';\n\nfunction __insertCSS(code) {\n  if (!code || typeof document == 'undefined') return;\n  let head = document.head || document.getElementsByTagName('head')[0];\n  let style = document.createElement('style');\n  style.type = 'text/css';\n  head.appendChild(style);\n  style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));\n}\nimport * as DialogPrimitive from '@radix-ui/react-dialog';\nimport * as React from 'react';\nimport React__default, { useLayoutEffect, useEffect } from 'react';\nconst DrawerContext = React__default.createContext({\n  drawerRef: {\n    current: null\n  },\n  overlayRef: {\n    current: null\n  },\n  scaleBackground: () => {},\n  onPress: () => {},\n  onRelease: () => {},\n  onDrag: () => {},\n  onNestedDrag: () => {},\n  onNestedOpenChange: () => {},\n  onNestedRelease: () => {},\n  openProp: undefined,\n  dismissible: false,\n  isOpen: false,\n  keyboardIsOpen: {\n    current: false\n  },\n  snapPointsOffset: null,\n  snapPoints: null,\n  modal: false,\n  shouldFade: false,\n  activeSnapPoint: null,\n  onOpenChange: () => {},\n  setActiveSnapPoint: () => {},\n  visible: false,\n  closeDrawer: () => {},\n  setVisible: () => {},\n  direction: 'bottom'\n});\nconst useDrawerContext = () => React__default.useContext(DrawerContext);\n__insertCSS(\"[vaul-drawer]{touch-action:none;transition:transform .5s cubic-bezier(.32, .72, 0, 1)}[vaul-drawer][vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[vaul-drawer][vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[vaul-drawer][vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[vaul-drawer][vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}.vaul-dragging .vaul-scrollable [vault-drawer-direction=top]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=bottom]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=left]{overflow-x:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=right]{overflow-x:hidden!important}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-overlay]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[vaul-overlay][vaul-drawer-visible=true]{opacity:1}[vaul-drawer]::after{content:'';position:absolute;background:inherit;background-color:inherit}[vaul-drawer][vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[vaul-drawer][vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[vaul-overlay][vaul-snap-points=true]:not([vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[vaul-overlay][vaul-snap-points-overlay=true]:not([vaul-drawer-visible=false]){opacity:1}\");\n\n// This code comes from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\nfunction chain(...callbacks) {\n  return (...args) => {\n    for (let callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\nfunction isMac() {\n  return testPlatform(/^Mac/);\n}\nfunction isIPhone() {\n  return testPlatform(/^iPhone/);\n}\nfunction isIPad() {\n  return testPlatform(/^iPad/) ||\n  // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n  isMac() && navigator.maxTouchPoints > 1;\n}\nfunction isIOS() {\n  return isIPhone() || isIPad();\n}\nfunction testPlatform(re) {\n  return typeof window !== 'undefined' && window.navigator != null ? re.test(window.navigator.platform) : undefined;\n}\n// @ts-ignore\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\nfunction isScrollable(node) {\n  let style = window.getComputedStyle(node);\n  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\nfunction getScrollParent(node) {\n  if (isScrollable(node)) {\n    node = node.parentElement;\n  }\n  while (node && !isScrollable(node)) {\n    node = node.parentElement;\n  }\n  return node || document.scrollingElement || document.documentElement;\n}\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nfunction usePreventScroll(options = {}) {\n  let {\n    isDisabled\n  } = options;\n  useIsomorphicLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  return chain(setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n  let scrollable;\n  let lastY = 0;\n  let onTouchStart = e => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = getScrollParent(e.target);\n    if (scrollable === document.documentElement && scrollable === document.body) {\n      return;\n    }\n    lastY = e.changedTouches[0].pageY;\n  };\n  let onTouchMove = e => {\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead. Unfortunately, this disables bounce scrolling when at\n    // the top but it's the best we can do.\n    let y = e.changedTouches[0].pageY;\n    let scrollTop = scrollable.scrollTop;\n    let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n    if (bottom === 0) {\n      return;\n    }\n    if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {\n      e.preventDefault();\n    }\n    lastY = y;\n  };\n  let onTouchEnd = e => {\n    let target = e.target;\n    // Apply this change if we're not already focused on the target element\n    if (isInput(target) && target !== document.activeElement) {\n      e.preventDefault();\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n      // be done before the \"focus\" event, so we have to focus the element ourselves.\n      target.style.transform = 'translateY(-2000px)';\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n      });\n    }\n  };\n  let onFocus = e => {\n    let target = e.target;\n    if (isInput(target)) {\n      // Transform also needs to be applied in the focus event in cases where focus moves\n      // other than tapping on an input directly, e.g. the next/previous buttons in the\n      // software keyboard. In these cases, it seems applying the transform in the focus event\n      // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            visualViewport.addEventListener('resize', () => scrollIntoView(target), {\n              once: true\n            });\n          }\n        }\n      });\n    }\n  };\n  let restoreStyles = chain(setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`));\n  // // Scroll to the top. The negative margin on the body will make this appear the same.\n  // window.scrollTo(0, 0);\n  let removeEvents = chain(addEvent(document, 'touchstart', onTouchStart, {\n    passive: false,\n    capture: true\n  }), addEvent(document, 'touchmove', onTouchMove, {\n    passive: false,\n    capture: true\n  }), addEvent(document, 'touchend', onTouchEnd, {\n    passive: false,\n    capture: true\n  }), addEvent(document, 'focus', onFocus, true));\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreStyles();\n    removeEvents();\n    // window.scrollTo(scrollX, scrollY);\n  };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element, style, value) {\n  let cur = element.style[style];\n  element.style[style] = value;\n  return () => {\n    element.style[style] = cur;\n  };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent(target, event, handler, options) {\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\nfunction scrollIntoView(target) {\n  let root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = getScrollParent(target);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = target.getBoundingClientRect().top;\n      let targetBottom = target.getBoundingClientRect().bottom;\n      const keyboardHeight = scrollable.getBoundingClientRect().bottom;\n      if (targetBottom > keyboardHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n    // @ts-ignore\n    target = scrollable.parentElement;\n  }\n}\nfunction isInput(target) {\n  return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n\n// This code comes from https://github.com/radix-ui/primitives/tree/main/packages/react/compose-refs\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs(...refs) {\n  return node => refs.forEach(ref => setRef(ref, node));\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs(...refs) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\nlet previousBodyPosition = null;\nfunction usePositionFixed({\n  isOpen,\n  modal,\n  nested,\n  hasBeenOpened,\n  preventScrollRestoration\n}) {\n  const [activeUrl, setActiveUrl] = React__default.useState(typeof window !== 'undefined' ? window.location.href : '');\n  const scrollPos = React__default.useRef(0);\n  const setPositionFixed = React__default.useCallback(() => {\n    // If previousBodyPosition is already set, don't set it again.\n    if (previousBodyPosition === null && isOpen) {\n      previousBodyPosition = {\n        position: document.body.style.position,\n        top: document.body.style.top,\n        left: document.body.style.left,\n        height: document.body.style.height\n      };\n      // Update the dom inside an animation frame\n      const {\n        scrollX,\n        innerHeight\n      } = window;\n      document.body.style.setProperty('position', 'fixed', 'important');\n      document.body.style.top = `${-scrollPos.current}px`;\n      document.body.style.left = `${-scrollX}px`;\n      document.body.style.right = '0px';\n      document.body.style.height = 'auto';\n      setTimeout(() => requestAnimationFrame(() => {\n        // Attempt to check if the bottom bar appeared due to the position change\n        console.log(['scrollPosition', scrollPos.current, innerHeight]);\n        if (scrollPos.current >= innerHeight) {\n          // Move the content further up so that the bottom bar doesn't hide it\n          document.body.style.top = `${-scrollPos.current}px`;\n        }\n      }), 300);\n    }\n  }, [isOpen]);\n  const restorePositionSetting = React__default.useCallback(() => {\n    if (previousBodyPosition !== null) {\n      // Convert the position from \"px\" to Int\n      const y = -parseInt(document.body.style.top, 10);\n      const x = -parseInt(document.body.style.left, 10);\n      // Restore styles\n      document.body.style.position = previousBodyPosition.position;\n      document.body.style.top = previousBodyPosition.top;\n      document.body.style.left = previousBodyPosition.left;\n      document.body.style.height = previousBodyPosition.height;\n      document.body.style.right = 'unset';\n      requestAnimationFrame(() => {\n        if (preventScrollRestoration && activeUrl !== window.location.href) {\n          setActiveUrl(window.location.href);\n          return;\n        }\n        window.scrollTo(x, y);\n      });\n      previousBodyPosition = null;\n    }\n  }, [activeUrl]);\n  React__default.useEffect(() => {\n    function onScroll() {\n      scrollPos.current = window.scrollY;\n    }\n    onScroll();\n    window.addEventListener('scroll', onScroll);\n    return () => {\n      window.removeEventListener('scroll', onScroll);\n    };\n  }, []);\n  React__default.useEffect(() => {\n    if (nested || !hasBeenOpened) return;\n    // This is needed to force Safari toolbar to show **before** the drawer starts animating to prevent a gnarly shift from happening\n    if (isOpen) {\n      // avoid for standalone mode (PWA)\n      // const isStandalone = window.matchMedia('(display-mode: standalone)').matches;\n      // !isStandalone && setPositionFixed();\n      if (!modal) {\n        setTimeout(() => {\n          restorePositionSetting();\n        }, 500);\n      }\n    } else {\n      restorePositionSetting();\n    }\n  }, [isOpen, hasBeenOpened, activeUrl, modal, nested, setPositionFixed, restorePositionSetting]);\n  return {\n    restorePositionSetting\n  };\n}\nconst cache = new WeakMap();\nfunction set(el, styles, ignoreCache = false) {\n  if (!el || !(el instanceof HTMLElement) || !styles) return;\n  let originalStyles = {};\n  Object.entries(styles).forEach(([key, value]) => {\n    if (key.startsWith('--')) {\n      el.style.setProperty(key, value);\n      return;\n    }\n    originalStyles[key] = el.style[key];\n    el.style[key] = value;\n  });\n  if (ignoreCache) return;\n  cache.set(el, originalStyles);\n}\nfunction reset(el, prop) {\n  if (!el || !(el instanceof HTMLElement)) return;\n  let originalStyles = cache.get(el);\n  if (!originalStyles) {\n    return;\n  }\n  if (prop) {\n    el.style[prop] = originalStyles[prop];\n  } else {\n    Object.entries(originalStyles).forEach(([key, value]) => {\n      el.style[key] = value;\n    });\n  }\n}\nconst isVertical = direction => {\n  switch (direction) {\n    case 'top':\n    case 'bottom':\n      return true;\n    case 'left':\n    case 'right':\n      return false;\n    default:\n      return direction;\n  }\n};\nfunction getTranslate(element, direction) {\n  if (!element) {\n    return null;\n  }\n  const style = window.getComputedStyle(element);\n  const transform =\n  // @ts-ignore\n  style.transform || style.webkitTransform || style.mozTransform;\n  let mat = transform.match(/^matrix3d\\((.+)\\)$/);\n  if (mat) {\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n    return parseFloat(mat[1].split(', ')[isVertical(direction) ? 13 : 12]);\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n  mat = transform.match(/^matrix\\((.+)\\)$/);\n  return mat ? parseFloat(mat[1].split(', ')[isVertical(direction) ? 5 : 4]) : null;\n}\nfunction dampenValue(v) {\n  return 8 * (Math.log(v + 1) - 2);\n}\nconst TRANSITIONS = {\n  DURATION: 0.5,\n  EASE: [0.32, 0.72, 0, 1]\n};\nconst VELOCITY_THRESHOLD = 0.4;\n\n// This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\nfunction useCallbackRef(callback) {\n  const callbackRef = React__default.useRef(callback);\n  React__default.useEffect(() => {\n    callbackRef.current = callback;\n  });\n  // https://github.com/facebook/react/issues/19240\n  return React__default.useMemo(() => (...args) => callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args), []);\n}\nfunction useUncontrolledState({\n  defaultProp,\n  onChange\n}) {\n  const uncontrolledState = React__default.useState(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = React__default.useRef(value);\n  const handleChange = useCallbackRef(onChange);\n  React__default.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef, handleChange]);\n  return uncontrolledState;\n}\nfunction useControllableState({\n  prop,\n  defaultProp,\n  onChange = () => {}\n}) {\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({\n    defaultProp,\n    onChange\n  });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n  const handleChange = useCallbackRef(onChange);\n  const setValue = React__default.useCallback(nextValue => {\n    if (isControlled) {\n      const setter = nextValue;\n      const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n      if (value !== prop) handleChange(value);\n    } else {\n      setUncontrolledProp(nextValue);\n    }\n  }, [isControlled, prop, setUncontrolledProp, handleChange]);\n  return [value, setValue];\n}\nfunction useSnapPoints({\n  activeSnapPointProp,\n  setActiveSnapPointProp,\n  snapPoints,\n  drawerRef,\n  overlayRef,\n  fadeFromIndex,\n  onSnapPointChange,\n  direction = 'bottom'\n}) {\n  const [activeSnapPoint, setActiveSnapPoint] = useControllableState({\n    prop: activeSnapPointProp,\n    defaultProp: snapPoints == null ? void 0 : snapPoints[0],\n    onChange: setActiveSnapPointProp\n  });\n  const isLastSnapPoint = React__default.useMemo(() => activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null, [snapPoints, activeSnapPoint]);\n  const shouldFade = snapPoints && snapPoints.length > 0 && (fadeFromIndex || fadeFromIndex === 0) && !Number.isNaN(fadeFromIndex) && snapPoints[fadeFromIndex] === activeSnapPoint || !snapPoints;\n  const activeSnapPointIndex = React__default.useMemo(() => snapPoints == null ? void 0 : snapPoints.findIndex(snapPoint => snapPoint === activeSnapPoint), [snapPoints, activeSnapPoint]);\n  const snapPointsOffset = React__default.useMemo(() => {\n    var _snapPoints_map;\n    return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map(snapPoint => {\n      const hasWindow = typeof window !== 'undefined';\n      const isPx = typeof snapPoint === 'string';\n      let snapPointAsNumber = 0;\n      if (isPx) {\n        snapPointAsNumber = parseInt(snapPoint, 10);\n      }\n      if (isVertical(direction)) {\n        const height = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerHeight : 0;\n        if (hasWindow) {\n          return direction === 'bottom' ? window.innerHeight - height : -window.innerHeight + height;\n        }\n        return height;\n      }\n      const width = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerWidth : 0;\n      if (hasWindow) {\n        return direction === 'right' ? window.innerWidth - width : -window.innerWidth + width;\n      }\n      return width;\n    })) != null ? _snapPoints_map : [];\n  }, [snapPoints]);\n  const activeSnapPointOffset = React__default.useMemo(() => activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null, [snapPointsOffset, activeSnapPointIndex]);\n  const snapToPoint = React__default.useCallback(dimension => {\n    var _snapPointsOffset_findIndex;\n    const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex(snapPointDim => snapPointDim === dimension)) != null ? _snapPointsOffset_findIndex : null;\n    onSnapPointChange(newSnapPointIndex);\n    set(drawerRef.current, {\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      transform: isVertical(direction) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`\n    });\n    if (snapPointsOffset && newSnapPointIndex !== snapPointsOffset.length - 1 && newSnapPointIndex !== fadeFromIndex) {\n      set(overlayRef.current, {\n        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n        opacity: '0'\n      });\n    } else {\n      set(overlayRef.current, {\n        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n        opacity: '1'\n      });\n    }\n    setActiveSnapPoint(newSnapPointIndex !== null ? snapPoints == null ? void 0 : snapPoints[newSnapPointIndex] : null);\n  }, [drawerRef.current, snapPoints, snapPointsOffset, fadeFromIndex, overlayRef, setActiveSnapPoint]);\n  React__default.useEffect(() => {\n    if (activeSnapPointProp) {\n      var _snapPoints_findIndex;\n      const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex(snapPoint => snapPoint === activeSnapPointProp)) != null ? _snapPoints_findIndex : -1;\n      if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === 'number') {\n        snapToPoint(snapPointsOffset[newIndex]);\n      }\n    }\n  }, [activeSnapPointProp, snapPoints, snapPointsOffset, snapToPoint]);\n  function onRelease({\n    draggedDistance,\n    closeDrawer,\n    velocity,\n    dismissible\n  }) {\n    if (fadeFromIndex === undefined) return;\n    const currentPosition = direction === 'bottom' || direction === 'right' ? (activeSnapPointOffset != null ? activeSnapPointOffset : 0) - draggedDistance : (activeSnapPointOffset != null ? activeSnapPointOffset : 0) + draggedDistance;\n    const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n    const isFirst = activeSnapPointIndex === 0;\n    const hasDraggedUp = draggedDistance > 0;\n    if (isOverlaySnapPoint) {\n      set(overlayRef.current, {\n        transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n      });\n    }\n    if (velocity > 2 && !hasDraggedUp) {\n      if (dismissible) closeDrawer();else snapToPoint(snapPointsOffset[0]); // snap to initial point\n      return;\n    }\n    if (velocity > 2 && hasDraggedUp && snapPointsOffset && snapPoints) {\n      snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n      return;\n    }\n    // Find the closest snap point to the current position\n    const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr) => {\n      if (typeof prev !== 'number' || typeof curr !== 'number') return prev;\n      return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;\n    });\n    const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n    if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {\n      const dragDirection = hasDraggedUp ? 1 : -1; // 1 = up, -1 = down\n      // Don't do anything if we swipe upwards while being on the last snap point\n      if (dragDirection > 0 && isLastSnapPoint) {\n        snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n        return;\n      }\n      if (isFirst && dragDirection < 0 && dismissible) {\n        closeDrawer();\n      }\n      if (activeSnapPointIndex === null) return;\n      snapToPoint(snapPointsOffset[activeSnapPointIndex + dragDirection]);\n      return;\n    }\n    snapToPoint(closestSnapPoint);\n  }\n  function onDrag({\n    draggedDistance\n  }) {\n    if (activeSnapPointOffset === null) return;\n    const newValue = direction === 'bottom' || direction === 'right' ? activeSnapPointOffset - draggedDistance : activeSnapPointOffset + draggedDistance;\n    // Don't do anything if we exceed the last(biggest) snap point\n    if ((direction === 'bottom' || direction === 'right') && newValue < snapPointsOffset[snapPointsOffset.length - 1]) {\n      return;\n    }\n    if ((direction === 'top' || direction === 'left') && newValue > snapPointsOffset[snapPointsOffset.length - 1]) {\n      return;\n    }\n    set(drawerRef.current, {\n      transform: isVertical(direction) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`\n    });\n  }\n  function getPercentageDragged(absDraggedDistance, isDraggingDown) {\n    if (!snapPoints || typeof activeSnapPointIndex !== 'number' || !snapPointsOffset || fadeFromIndex === undefined) return null;\n    // If this is true we are dragging to a snap point that is supposed to have an overlay\n    const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n    const isOverlaySnapPointOrHigher = activeSnapPointIndex >= fadeFromIndex;\n    if (isOverlaySnapPointOrHigher && isDraggingDown) {\n      return 0;\n    }\n    // Don't animate, but still use this one if we are dragging away from the overlaySnapPoint\n    if (isOverlaySnapPoint && !isDraggingDown) return 1;\n    if (!shouldFade && !isOverlaySnapPoint) return null;\n    // Either fadeFrom index or the one before\n    const targetSnapPointIndex = isOverlaySnapPoint ? activeSnapPointIndex + 1 : activeSnapPointIndex - 1;\n    // Get the distance from overlaySnapPoint to the one before or vice-versa to calculate the opacity percentage accordingly\n    const snapPointDistance = isOverlaySnapPoint ? snapPointsOffset[targetSnapPointIndex] - snapPointsOffset[targetSnapPointIndex - 1] : snapPointsOffset[targetSnapPointIndex + 1] - snapPointsOffset[targetSnapPointIndex];\n    const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);\n    if (isOverlaySnapPoint) {\n      return 1 - percentageDragged;\n    } else {\n      return percentageDragged;\n    }\n  }\n  return {\n    isLastSnapPoint,\n    activeSnapPoint,\n    shouldFade,\n    getPercentageDragged,\n    setActiveSnapPoint,\n    activeSnapPointIndex,\n    onRelease,\n    onDrag,\n    snapPointsOffset\n  };\n}\nconst CLOSE_THRESHOLD = 0.25;\nconst SCROLL_LOCK_TIMEOUT = 100;\nconst BORDER_RADIUS = 8;\nconst NESTED_DISPLACEMENT = 16;\nconst WINDOW_TOP_OFFSET = 26;\nconst DRAG_CLASS = 'vaul-dragging';\nfunction Root({\n  open: openProp,\n  onOpenChange,\n  children,\n  shouldScaleBackground,\n  onDrag: onDragProp,\n  onRelease: onReleaseProp,\n  snapPoints,\n  nested = false,\n  closeThreshold = CLOSE_THRESHOLD,\n  scrollLockTimeout = SCROLL_LOCK_TIMEOUT,\n  dismissible = true,\n  fadeFromIndex = snapPoints && snapPoints.length - 1,\n  activeSnapPoint: activeSnapPointProp,\n  setActiveSnapPoint: setActiveSnapPointProp,\n  fixed,\n  modal = true,\n  onClose,\n  direction = 'bottom',\n  preventScrollRestoration = true,\n  disablePreventScroll = false\n}) {\n  var _drawerRef_current;\n  const [isOpen = false, setIsOpen] = React__default.useState(false);\n  const [hasBeenOpened, setHasBeenOpened] = React__default.useState(false);\n  // Not visible = translateY(100%)\n  const [visible, setVisible] = React__default.useState(false);\n  const [mounted, setMounted] = React__default.useState(false);\n  const [isDragging, setIsDragging] = React__default.useState(false);\n  const [justReleased, setJustReleased] = React__default.useState(false);\n  const overlayRef = React__default.useRef(null);\n  const openTime = React__default.useRef(null);\n  const dragStartTime = React__default.useRef(null);\n  const dragEndTime = React__default.useRef(null);\n  const lastTimeDragPrevented = React__default.useRef(null);\n  const isAllowedToDrag = React__default.useRef(false);\n  const nestedOpenChangeTimer = React__default.useRef(null);\n  const pointerStart = React__default.useRef(0);\n  const keyboardIsOpen = React__default.useRef(false);\n  const previousDiffFromInitial = React__default.useRef(0);\n  const drawerRef = React__default.useRef(null);\n  const drawerHeightRef = React__default.useRef(((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0);\n  const initialDrawerHeight = React__default.useRef(0);\n  const onSnapPointChange = React__default.useCallback(activeSnapPointIndex => {\n    // Change openTime ref when we reach the last snap point to prevent dragging for 500ms incase it's scrollable.\n    if (snapPoints && activeSnapPointIndex === snapPointsOffset.length - 1) openTime.current = new Date();\n  }, []);\n  const {\n    activeSnapPoint,\n    activeSnapPointIndex,\n    setActiveSnapPoint,\n    onRelease: onReleaseSnapPoints,\n    snapPointsOffset,\n    onDrag: onDragSnapPoints,\n    shouldFade,\n    getPercentageDragged: getSnapPointsPercentageDragged\n  } = useSnapPoints({\n    snapPoints,\n    activeSnapPointProp,\n    setActiveSnapPointProp,\n    drawerRef,\n    fadeFromIndex,\n    overlayRef,\n    onSnapPointChange,\n    direction\n  });\n  usePreventScroll({\n    isDisabled: !isOpen || isDragging || !modal || justReleased || !hasBeenOpened || disablePreventScroll\n  });\n  const {\n    restorePositionSetting\n  } = usePositionFixed({\n    isOpen,\n    modal,\n    nested,\n    hasBeenOpened,\n    preventScrollRestoration\n  });\n  function getScale() {\n    return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\n  }\n  function onPress(event) {\n    var _drawerRef_current;\n    if (!dismissible && !snapPoints) return;\n    if (drawerRef.current && !drawerRef.current.contains(event.target)) return;\n    drawerHeightRef.current = ((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0;\n    setIsDragging(true);\n    dragStartTime.current = new Date();\n    // iOS doesn't trigger mouseUp after scrolling so we need to listen to touched in order to disallow dragging\n    if (isIOS()) {\n      window.addEventListener('touchend', () => isAllowedToDrag.current = false, {\n        once: true\n      });\n    }\n    // Ensure we maintain correct pointer capture even when going outside of the drawer\n    event.target.setPointerCapture(event.pointerId);\n    pointerStart.current = isVertical(direction) ? event.clientY : event.clientX;\n  }\n  function shouldDrag(el, isDraggingInDirection) {\n    var _window_getSelection;\n    let element = el;\n    const highlightedText = (_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString();\n    const swipeAmount = drawerRef.current ? getTranslate(drawerRef.current, direction) : null;\n    const date = new Date();\n    if (element.hasAttribute('data-vaul-no-drag') || element.closest('[data-vaul-no-drag]')) {\n      return false;\n    }\n    if (direction === 'right' || direction === 'left') {\n      return true;\n    }\n    // Allow scrolling when animating\n    if (openTime.current && date.getTime() - openTime.current.getTime() < 500) {\n      return false;\n    }\n    if (swipeAmount !== null) {\n      if (direction === 'bottom' ? swipeAmount > 0 : swipeAmount < 0) {\n        return true;\n      }\n    }\n    // Don't drag if there's highlighted text\n    if (highlightedText && highlightedText.length > 0) {\n      return false;\n    }\n    // Disallow dragging if drawer was scrolled within `scrollLockTimeout`\n    if (lastTimeDragPrevented.current && date.getTime() - lastTimeDragPrevented.current.getTime() < scrollLockTimeout && swipeAmount === 0) {\n      lastTimeDragPrevented.current = date;\n      return false;\n    }\n    if (isDraggingInDirection) {\n      lastTimeDragPrevented.current = date;\n      // We are dragging down so we should allow scrolling\n      return false;\n    }\n    // Keep climbing up the DOM tree as long as there's a parent\n    while (element) {\n      // Check if the element is scrollable\n      if (element.scrollHeight > element.clientHeight) {\n        if (element.scrollTop !== 0) {\n          lastTimeDragPrevented.current = new Date();\n          // The element is scrollable and not scrolled to the top, so don't drag\n          return false;\n        }\n        if (element.getAttribute('role') === 'dialog') {\n          return true;\n        }\n      }\n      // Move up to the parent element\n      element = element.parentNode;\n    }\n    // No scrollable parents not scrolled to the top found, so drag\n    return true;\n  }\n  function onDrag(event) {\n    if (!drawerRef.current) {\n      return;\n    }\n    // We need to know how much of the drawer has been dragged in percentages so that we can transform background accordingly\n    if (isDragging) {\n      const directionMultiplier = direction === 'bottom' || direction === 'right' ? 1 : -1;\n      const draggedDistance = (pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX)) * directionMultiplier;\n      const isDraggingInDirection = draggedDistance > 0;\n      // Pre condition for disallowing dragging in the close direction.\n      const noCloseSnapPointsPreCondition = snapPoints && !dismissible && !isDraggingInDirection;\n      // Disallow dragging down to close when first snap point is the active one and dismissible prop is set to false.\n      if (noCloseSnapPointsPreCondition && activeSnapPointIndex === 0) return;\n      // We need to capture last time when drag with scroll was triggered and have a timeout between\n      const absDraggedDistance = Math.abs(draggedDistance);\n      const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n      // Calculate the percentage dragged, where 1 is the closed position\n      let percentageDragged = absDraggedDistance / drawerHeightRef.current;\n      const snapPointPercentageDragged = getSnapPointsPercentageDragged(absDraggedDistance, isDraggingInDirection);\n      if (snapPointPercentageDragged !== null) {\n        percentageDragged = snapPointPercentageDragged;\n      }\n      // Disallow close dragging beyond the smallest snap point.\n      if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {\n        return;\n      }\n      if (!isAllowedToDrag.current && !shouldDrag(event.target, isDraggingInDirection)) return;\n      drawerRef.current.classList.add(DRAG_CLASS);\n      // If shouldDrag gave true once after pressing down on the drawer, we set isAllowedToDrag to true and it will remain true until we let go, there's no reason to disable dragging mid way, ever, and that's the solution to it\n      isAllowedToDrag.current = true;\n      set(drawerRef.current, {\n        transition: 'none'\n      });\n      set(overlayRef.current, {\n        transition: 'none'\n      });\n      if (snapPoints) {\n        onDragSnapPoints({\n          draggedDistance\n        });\n      }\n      // Run this only if snapPoints are not defined or if we are at the last snap point (highest one)\n      if (isDraggingInDirection && !snapPoints) {\n        const dampenedDraggedDistance = dampenValue(draggedDistance);\n        const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;\n        set(drawerRef.current, {\n          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n        });\n        return;\n      }\n      const opacityValue = 1 - percentageDragged;\n      if (shouldFade || fadeFromIndex && activeSnapPointIndex === fadeFromIndex - 1) {\n        onDragProp == null ? void 0 : onDragProp(event, percentageDragged);\n        set(overlayRef.current, {\n          opacity: `${opacityValue}`,\n          transition: 'none'\n        }, true);\n      }\n      if (wrapper && overlayRef.current && shouldScaleBackground) {\n        // Calculate percentageDragged as a fraction (0 to 1)\n        const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);\n        const borderRadiusValue = 8 - percentageDragged * 8;\n        const translateValue = Math.max(0, 14 - percentageDragged * 14);\n        set(wrapper, {\n          borderRadius: `${borderRadiusValue}px`,\n          transform: isVertical(direction) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,\n          transition: 'none'\n        }, true);\n      }\n      if (!snapPoints) {\n        const translateValue = absDraggedDistance * directionMultiplier;\n        set(drawerRef.current, {\n          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n        });\n      }\n    }\n  }\n  React__default.useEffect(() => {\n    return () => {\n      scaleBackground(false);\n      restorePositionSetting();\n    };\n  }, []);\n  React__default.useEffect(() => {\n    var _window_visualViewport;\n    function onVisualViewportChange() {\n      if (!drawerRef.current) return;\n      const focusedElement = document.activeElement;\n      if (isInput(focusedElement) || keyboardIsOpen.current) {\n        var _window_visualViewport;\n        const visualViewportHeight = ((_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.height) || 0;\n        // This is the height of the keyboard\n        let diffFromInitial = window.innerHeight - visualViewportHeight;\n        const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;\n        if (!initialDrawerHeight.current) {\n          initialDrawerHeight.current = drawerHeight;\n        }\n        const offsetFromTop = drawerRef.current.getBoundingClientRect().top;\n        // visualViewport height may change due to some subtle changes to the keyboard. Checking if the height changed by 60 or more will make sure that they keyboard really changed its open state.\n        if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {\n          keyboardIsOpen.current = !keyboardIsOpen.current;\n        }\n        if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {\n          const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;\n          diffFromInitial += activeSnapPointHeight;\n        }\n        previousDiffFromInitial.current = diffFromInitial;\n        // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can correctly check if the input is in view\n        if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {\n          const height = drawerRef.current.getBoundingClientRect().height;\n          let newDrawerHeight = height;\n          if (height > visualViewportHeight) {\n            newDrawerHeight = visualViewportHeight - WINDOW_TOP_OFFSET;\n          }\n          // When fixed, don't move the drawer upwards if there's space, but rather only change it's height so it's fully scrollable when the keyboard is open\n          if (fixed) {\n            drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;\n          } else {\n            drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;\n          }\n        } else {\n          drawerRef.current.style.height = `${initialDrawerHeight.current}px`;\n        }\n        if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {\n          drawerRef.current.style.bottom = `0px`;\n        } else {\n          // Negative bottom value would never make sense\n          drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;\n        }\n      }\n    }\n    (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener('resize', onVisualViewportChange);\n    return () => {\n      var _window_visualViewport;\n      return (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.removeEventListener('resize', onVisualViewportChange);\n    };\n  }, [activeSnapPointIndex, snapPoints, snapPointsOffset]);\n  function closeDrawer() {\n    if (!drawerRef.current) return;\n    cancelDrag();\n    onClose == null ? void 0 : onClose();\n    set(drawerRef.current, {\n      transform: isVertical(direction) ? `translate3d(0, ${direction === 'bottom' ? '100%' : '-100%'}, 0)` : `translate3d(${direction === 'right' ? '100%' : '-100%'}, 0, 0)`,\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n    });\n    set(overlayRef.current, {\n      opacity: '0',\n      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n    });\n    scaleBackground(false);\n    setTimeout(() => {\n      setVisible(false);\n      setIsOpen(false);\n    }, 300);\n    setTimeout(() => {\n      // reset(document.documentElement, 'scrollBehavior');\n      if (snapPoints) {\n        setActiveSnapPoint(snapPoints[0]);\n      }\n    }, TRANSITIONS.DURATION * 1000); // seconds to ms\n  }\n  React__default.useEffect(() => {\n    if (!isOpen && shouldScaleBackground) {\n      // Can't use `onAnimationEnd` as the component will be invisible by then\n      const id = setTimeout(() => {\n        reset(document.body);\n      }, 200);\n      return () => clearTimeout(id);\n    }\n  }, [isOpen, shouldScaleBackground]);\n  // LayoutEffect to prevent extra render where openProp and isOpen are not synced yet\n  React__default.useLayoutEffect(() => {\n    if (openProp) {\n      setIsOpen(true);\n      setHasBeenOpened(true);\n    } else {\n      closeDrawer();\n    }\n  }, [openProp]);\n  // This can be done much better\n  React__default.useEffect(() => {\n    if (mounted) {\n      onOpenChange == null ? void 0 : onOpenChange(isOpen);\n    }\n  }, [isOpen]);\n  React__default.useEffect(() => {\n    setMounted(true);\n  }, []);\n  function resetDrawer() {\n    if (!drawerRef.current) return;\n    const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n    const currentSwipeAmount = getTranslate(drawerRef.current, direction);\n    set(drawerRef.current, {\n      transform: 'translate3d(0, 0, 0)',\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n    });\n    set(overlayRef.current, {\n      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      opacity: '1'\n    });\n    // Don't reset background if swiped upwards\n    if (shouldScaleBackground && currentSwipeAmount && currentSwipeAmount > 0 && isOpen) {\n      set(wrapper, {\n        borderRadius: `${BORDER_RADIUS}px`,\n        overflow: 'hidden',\n        ...(isVertical(direction) ? {\n          transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n          transformOrigin: 'top'\n        } : {\n          transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n          transformOrigin: 'left'\n        }),\n        transitionProperty: 'transform, border-radius',\n        transitionDuration: `${TRANSITIONS.DURATION}s`,\n        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n      }, true);\n    }\n  }\n  function cancelDrag() {\n    if (!isDragging || !drawerRef.current) return;\n    drawerRef.current.classList.remove(DRAG_CLASS);\n    isAllowedToDrag.current = false;\n    setIsDragging(false);\n    dragEndTime.current = new Date();\n  }\n  function onRelease(event) {\n    if (!isDragging || !drawerRef.current) return;\n    drawerRef.current.classList.remove(DRAG_CLASS);\n    isAllowedToDrag.current = false;\n    setIsDragging(false);\n    dragEndTime.current = new Date();\n    const swipeAmount = getTranslate(drawerRef.current, direction);\n    if (!shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount)) return;\n    if (dragStartTime.current === null) return;\n    const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();\n    const distMoved = pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX);\n    const velocity = Math.abs(distMoved) / timeTaken;\n    if (velocity > 0.05) {\n      // `justReleased` is needed to prevent the drawer from focusing on an input when the drag ends, as it's not the intent most of the time.\n      setJustReleased(true);\n      setTimeout(() => {\n        setJustReleased(false);\n      }, 200);\n    }\n    if (snapPoints) {\n      const directionMultiplier = direction === 'bottom' || direction === 'right' ? 1 : -1;\n      onReleaseSnapPoints({\n        draggedDistance: distMoved * directionMultiplier,\n        closeDrawer,\n        velocity,\n        dismissible\n      });\n      onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n      return;\n    }\n    // Moved upwards, don't do anything\n    if (direction === 'bottom' || direction === 'right' ? distMoved > 0 : distMoved < 0) {\n      resetDrawer();\n      onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n      return;\n    }\n    if (velocity > VELOCITY_THRESHOLD) {\n      closeDrawer();\n      onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n      return;\n    }\n    var _drawerRef_current_getBoundingClientRect_height;\n    const visibleDrawerHeight = Math.min((_drawerRef_current_getBoundingClientRect_height = drawerRef.current.getBoundingClientRect().height) != null ? _drawerRef_current_getBoundingClientRect_height : 0, window.innerHeight);\n    if (swipeAmount >= visibleDrawerHeight * closeThreshold) {\n      closeDrawer();\n      onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n      return;\n    }\n    onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n    resetDrawer();\n  }\n  React__default.useEffect(() => {\n    // Trigger enter animation without using CSS animation\n    if (isOpen) {\n      set(document.documentElement, {\n        scrollBehavior: 'auto'\n      });\n      openTime.current = new Date();\n      scaleBackground(true);\n    }\n  }, [isOpen]);\n  React__default.useEffect(() => {\n    if (drawerRef.current && visible) {\n      var _drawerRef_current;\n      // Find all scrollable elements inside our drawer and assign a class to it so that we can disable overflow when dragging to prevent pointermove not being captured\n      const children = drawerRef == null ? void 0 : (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.querySelectorAll('*');\n      children == null ? void 0 : children.forEach(child => {\n        const htmlChild = child;\n        if (htmlChild.scrollHeight > htmlChild.clientHeight || htmlChild.scrollWidth > htmlChild.clientWidth) {\n          htmlChild.classList.add('vaul-scrollable');\n        }\n      });\n    }\n  }, [visible]);\n  function scaleBackground(open) {\n    const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n    if (!wrapper || !shouldScaleBackground) return;\n    if (open) {\n      // setting original styles initially\n      set(document.body, {\n        background: document.body.style.backgroundColor || document.body.style.background\n      });\n      // setting body styles, with cache ignored, so that we can get correct original styles in reset\n      set(document.body, {\n        background: 'black'\n      }, true);\n      set(wrapper, {\n        borderRadius: `${BORDER_RADIUS}px`,\n        overflow: 'hidden',\n        ...(isVertical(direction) ? {\n          transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n          transformOrigin: 'top'\n        } : {\n          transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n          transformOrigin: 'left'\n        }),\n        transitionProperty: 'transform, border-radius',\n        transitionDuration: `${TRANSITIONS.DURATION}s`,\n        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n      });\n    } else {\n      // Exit\n      reset(wrapper, 'overflow');\n      reset(wrapper, 'transform');\n      reset(wrapper, 'borderRadius');\n      set(wrapper, {\n        transitionProperty: 'transform, border-radius',\n        transitionDuration: `${TRANSITIONS.DURATION}s`,\n        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n      });\n    }\n  }\n  function onNestedOpenChange(o) {\n    const scale = o ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;\n    const y = o ? -NESTED_DISPLACEMENT : 0;\n    if (nestedOpenChangeTimer.current) {\n      window.clearTimeout(nestedOpenChangeTimer.current);\n    }\n    set(drawerRef.current, {\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      transform: `scale(${scale}) translate3d(0, ${y}px, 0)`\n    });\n    if (!o && drawerRef.current) {\n      nestedOpenChangeTimer.current = setTimeout(() => {\n        const translateValue = getTranslate(drawerRef.current, direction);\n        set(drawerRef.current, {\n          transition: 'none',\n          transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n        });\n      }, 500);\n    }\n  }\n  function onNestedDrag(event, percentageDragged) {\n    if (percentageDragged < 0) return;\n    const initialDim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n    const initialScale = (initialDim - NESTED_DISPLACEMENT) / initialDim;\n    const newScale = initialScale + percentageDragged * (1 - initialScale);\n    const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;\n    set(drawerRef.current, {\n      transform: isVertical(direction) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,\n      transition: 'none'\n    });\n  }\n  function onNestedRelease(event, o) {\n    const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n    const scale = o ? (dim - NESTED_DISPLACEMENT) / dim : 1;\n    const translate = o ? -NESTED_DISPLACEMENT : 0;\n    if (o) {\n      set(drawerRef.current, {\n        transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n        transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`\n      });\n    }\n  }\n  return /*#__PURE__*/React__default.createElement(DialogPrimitive.Root, {\n    modal: modal,\n    onOpenChange: o => {\n      if (openProp !== undefined) {\n        onOpenChange == null ? void 0 : onOpenChange(o);\n        return;\n      }\n      if (!o) {\n        closeDrawer();\n      } else {\n        setHasBeenOpened(true);\n        setIsOpen(o);\n      }\n    },\n    open: isOpen\n  }, /*#__PURE__*/React__default.createElement(DrawerContext.Provider, {\n    value: {\n      visible,\n      activeSnapPoint,\n      snapPoints,\n      setActiveSnapPoint,\n      drawerRef,\n      overlayRef,\n      scaleBackground,\n      onOpenChange,\n      onPress,\n      setVisible,\n      onRelease,\n      onDrag,\n      dismissible,\n      isOpen,\n      shouldFade,\n      closeDrawer,\n      onNestedDrag,\n      onNestedOpenChange,\n      onNestedRelease,\n      keyboardIsOpen,\n      openProp,\n      modal,\n      snapPointsOffset,\n      direction\n    }\n  }, children));\n}\nconst Overlay = /*#__PURE__*/React__default.forwardRef(function ({\n  children,\n  ...rest\n}, ref) {\n  const {\n    overlayRef,\n    snapPoints,\n    onRelease,\n    shouldFade,\n    isOpen,\n    visible\n  } = useDrawerContext();\n  const composedRef = useComposedRefs(ref, overlayRef);\n  const hasSnapPoints = snapPoints && snapPoints.length > 0;\n  return /*#__PURE__*/React__default.createElement(DialogPrimitive.Overlay, {\n    onMouseUp: onRelease,\n    ref: composedRef,\n    \"vaul-drawer-visible\": visible ? 'true' : 'false',\n    \"vaul-overlay\": \"\",\n    \"vaul-snap-points\": isOpen && hasSnapPoints ? 'true' : 'false',\n    \"vaul-snap-points-overlay\": isOpen && shouldFade ? 'true' : 'false',\n    ...rest\n  });\n});\nOverlay.displayName = 'Drawer.Overlay';\nconst Content = /*#__PURE__*/React__default.forwardRef(function ({\n  onOpenAutoFocus,\n  onPointerDownOutside,\n  onAnimationEnd,\n  style,\n  ...rest\n}, ref) {\n  const {\n    drawerRef,\n    onPress,\n    onRelease,\n    onDrag,\n    dismissible,\n    keyboardIsOpen,\n    snapPointsOffset,\n    visible,\n    closeDrawer,\n    modal,\n    openProp,\n    onOpenChange,\n    setVisible,\n    direction\n  } = useDrawerContext();\n  const composedRef = useComposedRefs(ref, drawerRef);\n  const pointerStartRef = React__default.useRef(null);\n  React__default.useEffect(() => {\n    // Trigger enter animation without using CSS animation\n    setVisible(true);\n  }, []);\n  const isDeltaInDirection = (delta, direction, threshold = 0) => {\n    const deltaX = Math.abs(delta.x);\n    const deltaY = Math.abs(delta.y);\n    const isDeltaX = deltaX > deltaY;\n    if (direction === 'left' || direction === 'right') {\n      return isDeltaX && deltaX > threshold;\n    } else {\n      return !isDeltaX && deltaY > threshold;\n    }\n  };\n  return /*#__PURE__*/React__default.createElement(DialogPrimitive.Content, {\n    \"vaul-drawer\": \"\",\n    \"vaul-drawer-direction\": direction,\n    \"vaul-drawer-visible\": visible ? 'true' : 'false',\n    ...rest,\n    ref: composedRef,\n    style: snapPointsOffset && snapPointsOffset.length > 0 ? {\n      '--snap-point-height': `${snapPointsOffset[0]}px`,\n      ...style\n    } : style,\n    onOpenAutoFocus: e => {\n      if (onOpenAutoFocus) {\n        onOpenAutoFocus(e);\n      } else {\n        var _drawerRef_current;\n        e.preventDefault();\n        (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.focus();\n      }\n    },\n    onPointerDown: event => {\n      rest.onPointerDown == null ? void 0 : rest.onPointerDown.call(rest, event);\n      pointerStartRef.current = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      onPress(event);\n    },\n    onPointerDownOutside: e => {\n      onPointerDownOutside == null ? void 0 : onPointerDownOutside(e);\n      if (!modal || e.defaultPrevented) {\n        e.preventDefault();\n        return;\n      }\n      if (keyboardIsOpen.current) {\n        keyboardIsOpen.current = false;\n      }\n      e.preventDefault();\n      onOpenChange == null ? void 0 : onOpenChange(false);\n      if (!dismissible || openProp !== undefined) {\n        return;\n      }\n      closeDrawer();\n    },\n    onPointerMove: event => {\n      rest.onPointerMove == null ? void 0 : rest.onPointerMove.call(rest, event);\n      if (!pointerStartRef.current) return null;\n      const yPosition = event.clientY - pointerStartRef.current.y;\n      const xPosition = event.clientX - pointerStartRef.current.x;\n      const isHorizontalSwipe = ['left', 'right'].includes(direction);\n      const clamp = ['left', 'top'].includes(direction) ? Math.min : Math.max;\n      const clampedX = isHorizontalSwipe ? clamp(0, xPosition) : 0;\n      const clampedY = !isHorizontalSwipe ? clamp(0, yPosition) : 0;\n      const swipeStartThreshold = event.pointerType === 'touch' ? 10 : 2;\n      const delta = {\n        x: clampedX,\n        y: clampedY\n      };\n      const isAllowedToSwipe = isDeltaInDirection(delta, direction, swipeStartThreshold);\n      if (isAllowedToSwipe) onDrag(event);else if (Math.abs(xPosition) > swipeStartThreshold || Math.abs(yPosition) > swipeStartThreshold) {\n        pointerStartRef.current = null;\n      }\n    },\n    onPointerUp: event => {\n      rest.onPointerUp == null ? void 0 : rest.onPointerUp.call(rest, event);\n      pointerStartRef.current = null;\n      onRelease(event);\n    }\n  });\n});\nContent.displayName = 'Drawer.Content';\nfunction NestedRoot({\n  onDrag,\n  onOpenChange,\n  ...rest\n}) {\n  const {\n    onNestedDrag,\n    onNestedOpenChange,\n    onNestedRelease\n  } = useDrawerContext();\n  if (!onNestedDrag) {\n    throw new Error('Drawer.NestedRoot must be placed in another drawer');\n  }\n  return /*#__PURE__*/React__default.createElement(Root, {\n    nested: true,\n    onClose: () => {\n      onNestedOpenChange(false);\n    },\n    onDrag: (e, p) => {\n      onNestedDrag(e, p);\n      onDrag == null ? void 0 : onDrag(e, p);\n    },\n    onOpenChange: o => {\n      if (o) {\n        onNestedOpenChange(o);\n      }\n      onOpenChange == null ? void 0 : onOpenChange(o);\n    },\n    onRelease: onNestedRelease,\n    ...rest\n  });\n}\nconst Drawer = {\n  Root,\n  NestedRoot,\n  Content,\n  Overlay,\n  Trigger: DialogPrimitive.Trigger,\n  Portal: DialogPrimitive.Portal,\n  Close: DialogPrimitive.Close,\n  Title: DialogPrimitive.Title,\n  Description: DialogPrimitive.Description\n};\nexport { Drawer };","map":{"version":3,"names":["__insertCSS","code","document","head","getElementsByTagName","style","createElement","type","appendChild","styleSheet","cssText","createTextNode","DialogPrimitive","React","React__default","useLayoutEffect","useEffect","DrawerContext","createContext","drawerRef","current","overlayRef","scaleBackground","onPress","onRelease","onDrag","onNestedDrag","onNestedOpenChange","onNestedRelease","openProp","undefined","dismissible","isOpen","keyboardIsOpen","snapPointsOffset","snapPoints","modal","shouldFade","activeSnapPoint","onOpenChange","setActiveSnapPoint","visible","closeDrawer","setVisible","direction","useDrawerContext","useContext","useIsomorphicLayoutEffect","window","chain","callbacks","args","callback","isMac","testPlatform","isIPhone","isIPad","navigator","maxTouchPoints","isIOS","re","test","platform","visualViewport","isScrollable","node","getComputedStyle","overflow","overflowX","overflowY","getScrollParent","parentElement","scrollingElement","documentElement","nonTextInputTypes","Set","preventScrollCount","restore","usePreventScroll","options","isDisabled","preventScrollMobileSafari","preventScrollStandard","setStyle","innerWidth","clientWidth","scrollable","lastY","onTouchStart","e","target","body","changedTouches","pageY","onTouchMove","preventDefault","y","scrollTop","bottom","scrollHeight","clientHeight","onTouchEnd","isInput","activeElement","transform","focus","requestAnimationFrame","onFocus","height","innerHeight","scrollIntoView","addEventListener","once","restoreStyles","removeEvents","addEvent","passive","capture","element","value","cur","event","handler","removeEventListener","root","scrollableTop","getBoundingClientRect","top","targetTop","targetBottom","keyboardHeight","HTMLInputElement","has","HTMLTextAreaElement","HTMLElement","isContentEditable","setRef","ref","composeRefs","refs","forEach","useComposedRefs","useCallback","previousBodyPosition","usePositionFixed","nested","hasBeenOpened","preventScrollRestoration","activeUrl","setActiveUrl","useState","location","href","scrollPos","useRef","setPositionFixed","position","left","scrollX","setProperty","right","setTimeout","console","log","restorePositionSetting","parseInt","x","scrollTo","onScroll","scrollY","cache","WeakMap","set","el","styles","ignoreCache","originalStyles","Object","entries","key","startsWith","reset","prop","get","isVertical","getTranslate","webkitTransform","mozTransform","mat","match","parseFloat","split","dampenValue","v","Math","TRANSITIONS","DURATION","EASE","VELOCITY_THRESHOLD","useCallbackRef","callbackRef","useMemo","call","useUncontrolledState","defaultProp","onChange","uncontrolledState","prevValueRef","handleChange","useControllableState","uncontrolledProp","setUncontrolledProp","isControlled","setValue","nextValue","setter","useSnapPoints","activeSnapPointProp","setActiveSnapPointProp","fadeFromIndex","onSnapPointChange","isLastSnapPoint","length","Number","isNaN","activeSnapPointIndex","findIndex","snapPoint","_snapPoints_map","map","hasWindow","isPx","snapPointAsNumber","width","activeSnapPointOffset","snapToPoint","dimension","_snapPointsOffset_findIndex","newSnapPointIndex","snapPointDim","transition","join","opacity","_snapPoints_findIndex","newIndex","draggedDistance","velocity","currentPosition","isOverlaySnapPoint","isFirst","hasDraggedUp","closestSnapPoint","reduce","prev","curr","abs","dim","dragDirection","newValue","getPercentageDragged","absDraggedDistance","isDraggingDown","isOverlaySnapPointOrHigher","targetSnapPointIndex","snapPointDistance","percentageDragged","CLOSE_THRESHOLD","SCROLL_LOCK_TIMEOUT","BORDER_RADIUS","NESTED_DISPLACEMENT","WINDOW_TOP_OFFSET","DRAG_CLASS","Root","open","children","shouldScaleBackground","onDragProp","onReleaseProp","closeThreshold","scrollLockTimeout","fixed","onClose","disablePreventScroll","_drawerRef_current","setIsOpen","setHasBeenOpened","mounted","setMounted","isDragging","setIsDragging","justReleased","setJustReleased","openTime","dragStartTime","dragEndTime","lastTimeDragPrevented","isAllowedToDrag","nestedOpenChangeTimer","pointerStart","previousDiffFromInitial","drawerHeightRef","initialDrawerHeight","Date","onReleaseSnapPoints","onDragSnapPoints","getSnapPointsPercentageDragged","getScale","contains","setPointerCapture","pointerId","clientY","clientX","shouldDrag","isDraggingInDirection","_window_getSelection","highlightedText","getSelection","toString","swipeAmount","date","hasAttribute","closest","getTime","getAttribute","parentNode","directionMultiplier","noCloseSnapPointsPreCondition","wrapper","querySelector","snapPointPercentageDragged","classList","add","dampenedDraggedDistance","translateValue","min","opacityValue","scaleValue","borderRadiusValue","max","borderRadius","_window_visualViewport","onVisualViewportChange","focusedElement","visualViewportHeight","diffFromInitial","drawerHeight","offsetFromTop","activeSnapPointHeight","newDrawerHeight","cancelDrag","id","clearTimeout","resetDrawer","currentSwipeAmount","transformOrigin","transitionProperty","transitionDuration","transitionTimingFunction","remove","timeTaken","distMoved","_drawerRef_current_getBoundingClientRect_height","visibleDrawerHeight","scrollBehavior","querySelectorAll","child","htmlChild","scrollWidth","background","backgroundColor","o","scale","initialDim","initialScale","newScale","newTranslate","translate","Provider","Overlay","forwardRef","rest","composedRef","hasSnapPoints","onMouseUp","displayName","Content","onOpenAutoFocus","onPointerDownOutside","onAnimationEnd","pointerStartRef","isDeltaInDirection","delta","threshold","deltaX","deltaY","isDeltaX","onPointerDown","defaultPrevented","onPointerMove","yPosition","xPosition","isHorizontalSwipe","includes","clamp","clampedX","clampedY","swipeStartThreshold","pointerType","isAllowedToSwipe","onPointerUp","NestedRoot","Error","p","Drawer","Trigger","Portal","Close","Title","Description"],"sources":["/home/dmitry/Projects/MEPhI/MEPhI360/app/node_modules/@xelene/vaul-with-scroll-fix/dist/index.mjs"],"sourcesContent":["'use client';\nfunction __insertCSS(code) {\n  if (!code || typeof document == 'undefined') return\n  let head = document.head || document.getElementsByTagName('head')[0]\n  let style = document.createElement('style')\n  style.type = 'text/css'\n  head.appendChild(style)\n  ;style.styleSheet ? (style.styleSheet.cssText = code) : style.appendChild(document.createTextNode(code))\n}\n\nimport * as DialogPrimitive from '@radix-ui/react-dialog';\nimport * as React from 'react';\nimport React__default, { useLayoutEffect, useEffect } from 'react';\n\nconst DrawerContext = React__default.createContext({\n    drawerRef: {\n        current: null\n    },\n    overlayRef: {\n        current: null\n    },\n    scaleBackground: ()=>{},\n    onPress: ()=>{},\n    onRelease: ()=>{},\n    onDrag: ()=>{},\n    onNestedDrag: ()=>{},\n    onNestedOpenChange: ()=>{},\n    onNestedRelease: ()=>{},\n    openProp: undefined,\n    dismissible: false,\n    isOpen: false,\n    keyboardIsOpen: {\n        current: false\n    },\n    snapPointsOffset: null,\n    snapPoints: null,\n    modal: false,\n    shouldFade: false,\n    activeSnapPoint: null,\n    onOpenChange: ()=>{},\n    setActiveSnapPoint: ()=>{},\n    visible: false,\n    closeDrawer: ()=>{},\n    setVisible: ()=>{},\n    direction: 'bottom'\n});\nconst useDrawerContext = ()=>React__default.useContext(DrawerContext);\n\n__insertCSS(\"[vaul-drawer]{touch-action:none;transition:transform .5s cubic-bezier(.32, .72, 0, 1)}[vaul-drawer][vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[vaul-drawer][vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[vaul-drawer][vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[vaul-drawer][vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}.vaul-dragging .vaul-scrollable [vault-drawer-direction=top]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=bottom]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=left]{overflow-x:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=right]{overflow-x:hidden!important}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-overlay]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[vaul-overlay][vaul-drawer-visible=true]{opacity:1}[vaul-drawer]::after{content:'';position:absolute;background:inherit;background-color:inherit}[vaul-drawer][vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[vaul-drawer][vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[vaul-overlay][vaul-snap-points=true]:not([vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[vaul-overlay][vaul-snap-points-overlay=true]:not([vaul-drawer-visible=false]){opacity:1}\");\n\n// This code comes from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\nfunction chain(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks){\n            if (typeof callback === 'function') {\n                callback(...args);\n            }\n        }\n    };\n}\nfunction isMac() {\n    return testPlatform(/^Mac/);\n}\nfunction isIPhone() {\n    return testPlatform(/^iPhone/);\n}\nfunction isIPad() {\n    return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    isMac() && navigator.maxTouchPoints > 1;\n}\nfunction isIOS() {\n    return isIPhone() || isIPad();\n}\nfunction testPlatform(re) {\n    return typeof window !== 'undefined' && window.navigator != null ? re.test(window.navigator.platform) : undefined;\n}\n// @ts-ignore\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\nfunction isScrollable(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\nfunction getScrollParent(node) {\n    if (isScrollable(node)) {\n        node = node.parentElement;\n    }\n    while(node && !isScrollable(node)){\n        node = node.parentElement;\n    }\n    return node || document.scrollingElement || document.documentElement;\n}\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n    'checkbox',\n    'radio',\n    'range',\n    'color',\n    'file',\n    'image',\n    'button',\n    'submit',\n    'reset'\n]);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */ function usePreventScroll(options = {}) {\n    let { isDisabled } = options;\n    useIsomorphicLayoutEffect(()=>{\n        if (isDisabled) {\n            return;\n        }\n        preventScrollCount++;\n        if (preventScrollCount === 1) {\n            if (isIOS()) {\n                restore = preventScrollMobileSafari();\n            } else {\n                restore = preventScrollStandard();\n            }\n        }\n        return ()=>{\n            preventScrollCount--;\n            if (preventScrollCount === 0) {\n                restore();\n            }\n        };\n    }, [\n        isDisabled\n    ]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n    return chain(setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n    let scrollable;\n    let lastY = 0;\n    let onTouchStart = (e)=>{\n        // Store the nearest scrollable parent element from the element that the user touched.\n        scrollable = getScrollParent(e.target);\n        if (scrollable === document.documentElement && scrollable === document.body) {\n            return;\n        }\n        lastY = e.changedTouches[0].pageY;\n    };\n    let onTouchMove = (e)=>{\n        // Prevent scrolling the window.\n        if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n            e.preventDefault();\n            return;\n        }\n        // Prevent scrolling up when at the top and scrolling down when at the bottom\n        // of a nested scrollable area, otherwise mobile Safari will start scrolling\n        // the window instead. Unfortunately, this disables bounce scrolling when at\n        // the top but it's the best we can do.\n        let y = e.changedTouches[0].pageY;\n        let scrollTop = scrollable.scrollTop;\n        let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n        if (bottom === 0) {\n            return;\n        }\n        if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {\n            e.preventDefault();\n        }\n        lastY = y;\n    };\n    let onTouchEnd = (e)=>{\n        let target = e.target;\n        // Apply this change if we're not already focused on the target element\n        if (isInput(target) && target !== document.activeElement) {\n            e.preventDefault();\n            // Apply a transform to trick Safari into thinking the input is at the top of the page\n            // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n            // be done before the \"focus\" event, so we have to focus the element ourselves.\n            target.style.transform = 'translateY(-2000px)';\n            target.focus();\n            requestAnimationFrame(()=>{\n                target.style.transform = '';\n            });\n        }\n    };\n    let onFocus = (e)=>{\n        let target = e.target;\n        if (isInput(target)) {\n            // Transform also needs to be applied in the focus event in cases where focus moves\n            // other than tapping on an input directly, e.g. the next/previous buttons in the\n            // software keyboard. In these cases, it seems applying the transform in the focus event\n            // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️\n            target.style.transform = 'translateY(-2000px)';\n            requestAnimationFrame(()=>{\n                target.style.transform = '';\n                // This will have prevented the browser from scrolling the focused element into view,\n                // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n                if (visualViewport) {\n                    if (visualViewport.height < window.innerHeight) {\n                        // If the keyboard is already visible, do this after one additional frame\n                        // to wait for the transform to be removed.\n                        requestAnimationFrame(()=>{\n                            scrollIntoView(target);\n                        });\n                    } else {\n                        // Otherwise, wait for the visual viewport to resize before scrolling so we can\n                        // measure the correct position to scroll to.\n                        visualViewport.addEventListener('resize', ()=>scrollIntoView(target), {\n                            once: true\n                        });\n                    }\n                }\n            });\n        }\n    };\n    let restoreStyles = chain(setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`));\n    // // Scroll to the top. The negative margin on the body will make this appear the same.\n    // window.scrollTo(0, 0);\n    let removeEvents = chain(addEvent(document, 'touchstart', onTouchStart, {\n        passive: false,\n        capture: true\n    }), addEvent(document, 'touchmove', onTouchMove, {\n        passive: false,\n        capture: true\n    }), addEvent(document, 'touchend', onTouchEnd, {\n        passive: false,\n        capture: true\n    }), addEvent(document, 'focus', onFocus, true));\n    return ()=>{\n        // Restore styles and scroll the page back to where it was.\n        restoreStyles();\n        removeEvents();\n    // window.scrollTo(scrollX, scrollY);\n    };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element, style, value) {\n    let cur = element.style[style];\n    element.style[style] = value;\n    return ()=>{\n        element.style[style] = cur;\n    };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent(target, event, handler, options) {\n    // @ts-ignore\n    target.addEventListener(event, handler, options);\n    return ()=>{\n        // @ts-ignore\n        target.removeEventListener(event, handler, options);\n    };\n}\nfunction scrollIntoView(target) {\n    let root = document.scrollingElement || document.documentElement;\n    while(target && target !== root){\n        // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n        let scrollable = getScrollParent(target);\n        if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n            let scrollableTop = scrollable.getBoundingClientRect().top;\n            let targetTop = target.getBoundingClientRect().top;\n            let targetBottom = target.getBoundingClientRect().bottom;\n            const keyboardHeight = scrollable.getBoundingClientRect().bottom;\n            if (targetBottom > keyboardHeight) {\n                scrollable.scrollTop += targetTop - scrollableTop;\n            }\n        }\n        // @ts-ignore\n        target = scrollable.parentElement;\n    }\n}\nfunction isInput(target) {\n    return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n\n// This code comes from https://github.com/radix-ui/primitives/tree/main/packages/react/compose-refs\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */ function setRef(ref, value) {\n    if (typeof ref === 'function') {\n        ref(value);\n    } else if (ref !== null && ref !== undefined) {\n        ref.current = value;\n    }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */ function composeRefs(...refs) {\n    return (node)=>refs.forEach((ref)=>setRef(ref, node));\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */ function useComposedRefs(...refs) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs);\n}\n\nlet previousBodyPosition = null;\nfunction usePositionFixed({ isOpen, modal, nested, hasBeenOpened, preventScrollRestoration }) {\n    const [activeUrl, setActiveUrl] = React__default.useState(typeof window !== 'undefined' ? window.location.href : '');\n    const scrollPos = React__default.useRef(0);\n    const setPositionFixed = React__default.useCallback(()=>{\n        // If previousBodyPosition is already set, don't set it again.\n        if (previousBodyPosition === null && isOpen) {\n            previousBodyPosition = {\n                position: document.body.style.position,\n                top: document.body.style.top,\n                left: document.body.style.left,\n                height: document.body.style.height\n            };\n            // Update the dom inside an animation frame\n            const { scrollX, innerHeight } = window;\n            document.body.style.setProperty('position', 'fixed', 'important');\n            document.body.style.top = `${-scrollPos.current}px`;\n            document.body.style.left = `${-scrollX}px`;\n            document.body.style.right = '0px';\n            document.body.style.height = 'auto';\n            setTimeout(()=>requestAnimationFrame(()=>{\n                    // Attempt to check if the bottom bar appeared due to the position change\n                    console.log([\n                        'scrollPosition',\n                        scrollPos.current,\n                        innerHeight\n                    ]);\n                    if (scrollPos.current >= innerHeight) {\n                        // Move the content further up so that the bottom bar doesn't hide it\n                        document.body.style.top = `${-scrollPos.current}px`;\n                    }\n                }), 300);\n        }\n    }, [\n        isOpen\n    ]);\n    const restorePositionSetting = React__default.useCallback(()=>{\n        if (previousBodyPosition !== null) {\n            // Convert the position from \"px\" to Int\n            const y = -parseInt(document.body.style.top, 10);\n            const x = -parseInt(document.body.style.left, 10);\n            // Restore styles\n            document.body.style.position = previousBodyPosition.position;\n            document.body.style.top = previousBodyPosition.top;\n            document.body.style.left = previousBodyPosition.left;\n            document.body.style.height = previousBodyPosition.height;\n            document.body.style.right = 'unset';\n            requestAnimationFrame(()=>{\n                if (preventScrollRestoration && activeUrl !== window.location.href) {\n                    setActiveUrl(window.location.href);\n                    return;\n                }\n                window.scrollTo(x, y);\n            });\n            previousBodyPosition = null;\n        }\n    }, [\n        activeUrl\n    ]);\n    React__default.useEffect(()=>{\n        function onScroll() {\n            scrollPos.current = window.scrollY;\n        }\n        onScroll();\n        window.addEventListener('scroll', onScroll);\n        return ()=>{\n            window.removeEventListener('scroll', onScroll);\n        };\n    }, []);\n    React__default.useEffect(()=>{\n        if (nested || !hasBeenOpened) return;\n        // This is needed to force Safari toolbar to show **before** the drawer starts animating to prevent a gnarly shift from happening\n        if (isOpen) {\n            // avoid for standalone mode (PWA)\n            // const isStandalone = window.matchMedia('(display-mode: standalone)').matches;\n            // !isStandalone && setPositionFixed();\n            if (!modal) {\n                setTimeout(()=>{\n                    restorePositionSetting();\n                }, 500);\n            }\n        } else {\n            restorePositionSetting();\n        }\n    }, [\n        isOpen,\n        hasBeenOpened,\n        activeUrl,\n        modal,\n        nested,\n        setPositionFixed,\n        restorePositionSetting\n    ]);\n    return {\n        restorePositionSetting\n    };\n}\n\nconst cache = new WeakMap();\nfunction set(el, styles, ignoreCache = false) {\n    if (!el || !(el instanceof HTMLElement) || !styles) return;\n    let originalStyles = {};\n    Object.entries(styles).forEach(([key, value])=>{\n        if (key.startsWith('--')) {\n            el.style.setProperty(key, value);\n            return;\n        }\n        originalStyles[key] = el.style[key];\n        el.style[key] = value;\n    });\n    if (ignoreCache) return;\n    cache.set(el, originalStyles);\n}\nfunction reset(el, prop) {\n    if (!el || !(el instanceof HTMLElement)) return;\n    let originalStyles = cache.get(el);\n    if (!originalStyles) {\n        return;\n    }\n    if (prop) {\n        el.style[prop] = originalStyles[prop];\n    } else {\n        Object.entries(originalStyles).forEach(([key, value])=>{\n            el.style[key] = value;\n        });\n    }\n}\nconst isVertical = (direction)=>{\n    switch(direction){\n        case 'top':\n        case 'bottom':\n            return true;\n        case 'left':\n        case 'right':\n            return false;\n        default:\n            return direction;\n    }\n};\nfunction getTranslate(element, direction) {\n    if (!element) {\n        return null;\n    }\n    const style = window.getComputedStyle(element);\n    const transform = // @ts-ignore\n    style.transform || style.webkitTransform || style.mozTransform;\n    let mat = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (mat) {\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n        return parseFloat(mat[1].split(', ')[isVertical(direction) ? 13 : 12]);\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n    mat = transform.match(/^matrix\\((.+)\\)$/);\n    return mat ? parseFloat(mat[1].split(', ')[isVertical(direction) ? 5 : 4]) : null;\n}\nfunction dampenValue(v) {\n    return 8 * (Math.log(v + 1) - 2);\n}\n\nconst TRANSITIONS = {\n    DURATION: 0.5,\n    EASE: [\n        0.32,\n        0.72,\n        0,\n        1\n    ]\n};\nconst VELOCITY_THRESHOLD = 0.4;\n\n// This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\nfunction useCallbackRef(callback) {\n    const callbackRef = React__default.useRef(callback);\n    React__default.useEffect(()=>{\n        callbackRef.current = callback;\n    });\n    // https://github.com/facebook/react/issues/19240\n    return React__default.useMemo(()=>(...args)=>callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args), []);\n}\nfunction useUncontrolledState({ defaultProp, onChange }) {\n    const uncontrolledState = React__default.useState(defaultProp);\n    const [value] = uncontrolledState;\n    const prevValueRef = React__default.useRef(value);\n    const handleChange = useCallbackRef(onChange);\n    React__default.useEffect(()=>{\n        if (prevValueRef.current !== value) {\n            handleChange(value);\n            prevValueRef.current = value;\n        }\n    }, [\n        value,\n        prevValueRef,\n        handleChange\n    ]);\n    return uncontrolledState;\n}\nfunction useControllableState({ prop, defaultProp, onChange = ()=>{} }) {\n    const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({\n        defaultProp,\n        onChange\n    });\n    const isControlled = prop !== undefined;\n    const value = isControlled ? prop : uncontrolledProp;\n    const handleChange = useCallbackRef(onChange);\n    const setValue = React__default.useCallback((nextValue)=>{\n        if (isControlled) {\n            const setter = nextValue;\n            const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n            if (value !== prop) handleChange(value);\n        } else {\n            setUncontrolledProp(nextValue);\n        }\n    }, [\n        isControlled,\n        prop,\n        setUncontrolledProp,\n        handleChange\n    ]);\n    return [\n        value,\n        setValue\n    ];\n}\n\nfunction useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints, drawerRef, overlayRef, fadeFromIndex, onSnapPointChange, direction = 'bottom' }) {\n    const [activeSnapPoint, setActiveSnapPoint] = useControllableState({\n        prop: activeSnapPointProp,\n        defaultProp: snapPoints == null ? void 0 : snapPoints[0],\n        onChange: setActiveSnapPointProp\n    });\n    const isLastSnapPoint = React__default.useMemo(()=>activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null, [\n        snapPoints,\n        activeSnapPoint\n    ]);\n    const shouldFade = snapPoints && snapPoints.length > 0 && (fadeFromIndex || fadeFromIndex === 0) && !Number.isNaN(fadeFromIndex) && snapPoints[fadeFromIndex] === activeSnapPoint || !snapPoints;\n    const activeSnapPointIndex = React__default.useMemo(()=>snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint)=>snapPoint === activeSnapPoint), [\n        snapPoints,\n        activeSnapPoint\n    ]);\n    const snapPointsOffset = React__default.useMemo(()=>{\n        var _snapPoints_map;\n        return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map((snapPoint)=>{\n            const hasWindow = typeof window !== 'undefined';\n            const isPx = typeof snapPoint === 'string';\n            let snapPointAsNumber = 0;\n            if (isPx) {\n                snapPointAsNumber = parseInt(snapPoint, 10);\n            }\n            if (isVertical(direction)) {\n                const height = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerHeight : 0;\n                if (hasWindow) {\n                    return direction === 'bottom' ? window.innerHeight - height : -window.innerHeight + height;\n                }\n                return height;\n            }\n            const width = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerWidth : 0;\n            if (hasWindow) {\n                return direction === 'right' ? window.innerWidth - width : -window.innerWidth + width;\n            }\n            return width;\n        })) != null ? _snapPoints_map : [];\n    }, [\n        snapPoints\n    ]);\n    const activeSnapPointOffset = React__default.useMemo(()=>activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null, [\n        snapPointsOffset,\n        activeSnapPointIndex\n    ]);\n    const snapToPoint = React__default.useCallback((dimension)=>{\n        var _snapPointsOffset_findIndex;\n        const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex((snapPointDim)=>snapPointDim === dimension)) != null ? _snapPointsOffset_findIndex : null;\n        onSnapPointChange(newSnapPointIndex);\n        set(drawerRef.current, {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n            transform: isVertical(direction) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`\n        });\n        if (snapPointsOffset && newSnapPointIndex !== snapPointsOffset.length - 1 && newSnapPointIndex !== fadeFromIndex) {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n                opacity: '0'\n            });\n        } else {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n                opacity: '1'\n            });\n        }\n        setActiveSnapPoint(newSnapPointIndex !== null ? snapPoints == null ? void 0 : snapPoints[newSnapPointIndex] : null);\n    }, [\n        drawerRef.current,\n        snapPoints,\n        snapPointsOffset,\n        fadeFromIndex,\n        overlayRef,\n        setActiveSnapPoint\n    ]);\n    React__default.useEffect(()=>{\n        if (activeSnapPointProp) {\n            var _snapPoints_findIndex;\n            const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint)=>snapPoint === activeSnapPointProp)) != null ? _snapPoints_findIndex : -1;\n            if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === 'number') {\n                snapToPoint(snapPointsOffset[newIndex]);\n            }\n        }\n    }, [\n        activeSnapPointProp,\n        snapPoints,\n        snapPointsOffset,\n        snapToPoint\n    ]);\n    function onRelease({ draggedDistance, closeDrawer, velocity, dismissible }) {\n        if (fadeFromIndex === undefined) return;\n        const currentPosition = direction === 'bottom' || direction === 'right' ? (activeSnapPointOffset != null ? activeSnapPointOffset : 0) - draggedDistance : (activeSnapPointOffset != null ? activeSnapPointOffset : 0) + draggedDistance;\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n        const isFirst = activeSnapPointIndex === 0;\n        const hasDraggedUp = draggedDistance > 0;\n        if (isOverlaySnapPoint) {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n            });\n        }\n        if (velocity > 2 && !hasDraggedUp) {\n            if (dismissible) closeDrawer();\n            else snapToPoint(snapPointsOffset[0]); // snap to initial point\n            return;\n        }\n        if (velocity > 2 && hasDraggedUp && snapPointsOffset && snapPoints) {\n            snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n            return;\n        }\n        // Find the closest snap point to the current position\n        const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr)=>{\n            if (typeof prev !== 'number' || typeof curr !== 'number') return prev;\n            return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;\n        });\n        const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {\n            const dragDirection = hasDraggedUp ? 1 : -1; // 1 = up, -1 = down\n            // Don't do anything if we swipe upwards while being on the last snap point\n            if (dragDirection > 0 && isLastSnapPoint) {\n                snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n                return;\n            }\n            if (isFirst && dragDirection < 0 && dismissible) {\n                closeDrawer();\n            }\n            if (activeSnapPointIndex === null) return;\n            snapToPoint(snapPointsOffset[activeSnapPointIndex + dragDirection]);\n            return;\n        }\n        snapToPoint(closestSnapPoint);\n    }\n    function onDrag({ draggedDistance }) {\n        if (activeSnapPointOffset === null) return;\n        const newValue = direction === 'bottom' || direction === 'right' ? activeSnapPointOffset - draggedDistance : activeSnapPointOffset + draggedDistance;\n        // Don't do anything if we exceed the last(biggest) snap point\n        if ((direction === 'bottom' || direction === 'right') && newValue < snapPointsOffset[snapPointsOffset.length - 1]) {\n            return;\n        }\n        if ((direction === 'top' || direction === 'left') && newValue > snapPointsOffset[snapPointsOffset.length - 1]) {\n            return;\n        }\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`\n        });\n    }\n    function getPercentageDragged(absDraggedDistance, isDraggingDown) {\n        if (!snapPoints || typeof activeSnapPointIndex !== 'number' || !snapPointsOffset || fadeFromIndex === undefined) return null;\n        // If this is true we are dragging to a snap point that is supposed to have an overlay\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n        const isOverlaySnapPointOrHigher = activeSnapPointIndex >= fadeFromIndex;\n        if (isOverlaySnapPointOrHigher && isDraggingDown) {\n            return 0;\n        }\n        // Don't animate, but still use this one if we are dragging away from the overlaySnapPoint\n        if (isOverlaySnapPoint && !isDraggingDown) return 1;\n        if (!shouldFade && !isOverlaySnapPoint) return null;\n        // Either fadeFrom index or the one before\n        const targetSnapPointIndex = isOverlaySnapPoint ? activeSnapPointIndex + 1 : activeSnapPointIndex - 1;\n        // Get the distance from overlaySnapPoint to the one before or vice-versa to calculate the opacity percentage accordingly\n        const snapPointDistance = isOverlaySnapPoint ? snapPointsOffset[targetSnapPointIndex] - snapPointsOffset[targetSnapPointIndex - 1] : snapPointsOffset[targetSnapPointIndex + 1] - snapPointsOffset[targetSnapPointIndex];\n        const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);\n        if (isOverlaySnapPoint) {\n            return 1 - percentageDragged;\n        } else {\n            return percentageDragged;\n        }\n    }\n    return {\n        isLastSnapPoint,\n        activeSnapPoint,\n        shouldFade,\n        getPercentageDragged,\n        setActiveSnapPoint,\n        activeSnapPointIndex,\n        onRelease,\n        onDrag,\n        snapPointsOffset\n    };\n}\n\nconst CLOSE_THRESHOLD = 0.25;\nconst SCROLL_LOCK_TIMEOUT = 100;\nconst BORDER_RADIUS = 8;\nconst NESTED_DISPLACEMENT = 16;\nconst WINDOW_TOP_OFFSET = 26;\nconst DRAG_CLASS = 'vaul-dragging';\nfunction Root({ open: openProp, onOpenChange, children, shouldScaleBackground, onDrag: onDragProp, onRelease: onReleaseProp, snapPoints, nested = false, closeThreshold = CLOSE_THRESHOLD, scrollLockTimeout = SCROLL_LOCK_TIMEOUT, dismissible = true, fadeFromIndex = snapPoints && snapPoints.length - 1, activeSnapPoint: activeSnapPointProp, setActiveSnapPoint: setActiveSnapPointProp, fixed, modal = true, onClose, direction = 'bottom', preventScrollRestoration = true, disablePreventScroll = false }) {\n    var _drawerRef_current;\n    const [isOpen = false, setIsOpen] = React__default.useState(false);\n    const [hasBeenOpened, setHasBeenOpened] = React__default.useState(false);\n    // Not visible = translateY(100%)\n    const [visible, setVisible] = React__default.useState(false);\n    const [mounted, setMounted] = React__default.useState(false);\n    const [isDragging, setIsDragging] = React__default.useState(false);\n    const [justReleased, setJustReleased] = React__default.useState(false);\n    const overlayRef = React__default.useRef(null);\n    const openTime = React__default.useRef(null);\n    const dragStartTime = React__default.useRef(null);\n    const dragEndTime = React__default.useRef(null);\n    const lastTimeDragPrevented = React__default.useRef(null);\n    const isAllowedToDrag = React__default.useRef(false);\n    const nestedOpenChangeTimer = React__default.useRef(null);\n    const pointerStart = React__default.useRef(0);\n    const keyboardIsOpen = React__default.useRef(false);\n    const previousDiffFromInitial = React__default.useRef(0);\n    const drawerRef = React__default.useRef(null);\n    const drawerHeightRef = React__default.useRef(((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0);\n    const initialDrawerHeight = React__default.useRef(0);\n    const onSnapPointChange = React__default.useCallback((activeSnapPointIndex)=>{\n        // Change openTime ref when we reach the last snap point to prevent dragging for 500ms incase it's scrollable.\n        if (snapPoints && activeSnapPointIndex === snapPointsOffset.length - 1) openTime.current = new Date();\n    }, []);\n    const { activeSnapPoint, activeSnapPointIndex, setActiveSnapPoint, onRelease: onReleaseSnapPoints, snapPointsOffset, onDrag: onDragSnapPoints, shouldFade, getPercentageDragged: getSnapPointsPercentageDragged } = useSnapPoints({\n        snapPoints,\n        activeSnapPointProp,\n        setActiveSnapPointProp,\n        drawerRef,\n        fadeFromIndex,\n        overlayRef,\n        onSnapPointChange,\n        direction\n    });\n    usePreventScroll({\n        isDisabled: !isOpen || isDragging || !modal || justReleased || !hasBeenOpened || disablePreventScroll\n    });\n    const { restorePositionSetting } = usePositionFixed({\n        isOpen,\n        modal,\n        nested,\n        hasBeenOpened,\n        preventScrollRestoration\n    });\n    function getScale() {\n        return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\n    }\n    function onPress(event) {\n        var _drawerRef_current;\n        if (!dismissible && !snapPoints) return;\n        if (drawerRef.current && !drawerRef.current.contains(event.target)) return;\n        drawerHeightRef.current = ((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0;\n        setIsDragging(true);\n        dragStartTime.current = new Date();\n        // iOS doesn't trigger mouseUp after scrolling so we need to listen to touched in order to disallow dragging\n        if (isIOS()) {\n            window.addEventListener('touchend', ()=>isAllowedToDrag.current = false, {\n                once: true\n            });\n        }\n        // Ensure we maintain correct pointer capture even when going outside of the drawer\n        event.target.setPointerCapture(event.pointerId);\n        pointerStart.current = isVertical(direction) ? event.clientY : event.clientX;\n    }\n    function shouldDrag(el, isDraggingInDirection) {\n        var _window_getSelection;\n        let element = el;\n        const highlightedText = (_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString();\n        const swipeAmount = drawerRef.current ? getTranslate(drawerRef.current, direction) : null;\n        const date = new Date();\n        if (element.hasAttribute('data-vaul-no-drag') || element.closest('[data-vaul-no-drag]')) {\n            return false;\n        }\n        if (direction === 'right' || direction === 'left') {\n            return true;\n        }\n        // Allow scrolling when animating\n        if (openTime.current && date.getTime() - openTime.current.getTime() < 500) {\n            return false;\n        }\n        if (swipeAmount !== null) {\n            if (direction === 'bottom' ? swipeAmount > 0 : swipeAmount < 0) {\n                return true;\n            }\n        }\n        // Don't drag if there's highlighted text\n        if (highlightedText && highlightedText.length > 0) {\n            return false;\n        }\n        // Disallow dragging if drawer was scrolled within `scrollLockTimeout`\n        if (lastTimeDragPrevented.current && date.getTime() - lastTimeDragPrevented.current.getTime() < scrollLockTimeout && swipeAmount === 0) {\n            lastTimeDragPrevented.current = date;\n            return false;\n        }\n        if (isDraggingInDirection) {\n            lastTimeDragPrevented.current = date;\n            // We are dragging down so we should allow scrolling\n            return false;\n        }\n        // Keep climbing up the DOM tree as long as there's a parent\n        while(element){\n            // Check if the element is scrollable\n            if (element.scrollHeight > element.clientHeight) {\n                if (element.scrollTop !== 0) {\n                    lastTimeDragPrevented.current = new Date();\n                    // The element is scrollable and not scrolled to the top, so don't drag\n                    return false;\n                }\n                if (element.getAttribute('role') === 'dialog') {\n                    return true;\n                }\n            }\n            // Move up to the parent element\n            element = element.parentNode;\n        }\n        // No scrollable parents not scrolled to the top found, so drag\n        return true;\n    }\n    function onDrag(event) {\n        if (!drawerRef.current) {\n            return;\n        }\n        // We need to know how much of the drawer has been dragged in percentages so that we can transform background accordingly\n        if (isDragging) {\n            const directionMultiplier = direction === 'bottom' || direction === 'right' ? 1 : -1;\n            const draggedDistance = (pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX)) * directionMultiplier;\n            const isDraggingInDirection = draggedDistance > 0;\n            // Pre condition for disallowing dragging in the close direction.\n            const noCloseSnapPointsPreCondition = snapPoints && !dismissible && !isDraggingInDirection;\n            // Disallow dragging down to close when first snap point is the active one and dismissible prop is set to false.\n            if (noCloseSnapPointsPreCondition && activeSnapPointIndex === 0) return;\n            // We need to capture last time when drag with scroll was triggered and have a timeout between\n            const absDraggedDistance = Math.abs(draggedDistance);\n            const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n            // Calculate the percentage dragged, where 1 is the closed position\n            let percentageDragged = absDraggedDistance / drawerHeightRef.current;\n            const snapPointPercentageDragged = getSnapPointsPercentageDragged(absDraggedDistance, isDraggingInDirection);\n            if (snapPointPercentageDragged !== null) {\n                percentageDragged = snapPointPercentageDragged;\n            }\n            // Disallow close dragging beyond the smallest snap point.\n            if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {\n                return;\n            }\n            if (!isAllowedToDrag.current && !shouldDrag(event.target, isDraggingInDirection)) return;\n            drawerRef.current.classList.add(DRAG_CLASS);\n            // If shouldDrag gave true once after pressing down on the drawer, we set isAllowedToDrag to true and it will remain true until we let go, there's no reason to disable dragging mid way, ever, and that's the solution to it\n            isAllowedToDrag.current = true;\n            set(drawerRef.current, {\n                transition: 'none'\n            });\n            set(overlayRef.current, {\n                transition: 'none'\n            });\n            if (snapPoints) {\n                onDragSnapPoints({\n                    draggedDistance\n                });\n            }\n            // Run this only if snapPoints are not defined or if we are at the last snap point (highest one)\n            if (isDraggingInDirection && !snapPoints) {\n                const dampenedDraggedDistance = dampenValue(draggedDistance);\n                const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;\n                set(drawerRef.current, {\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n                return;\n            }\n            const opacityValue = 1 - percentageDragged;\n            if (shouldFade || fadeFromIndex && activeSnapPointIndex === fadeFromIndex - 1) {\n                onDragProp == null ? void 0 : onDragProp(event, percentageDragged);\n                set(overlayRef.current, {\n                    opacity: `${opacityValue}`,\n                    transition: 'none'\n                }, true);\n            }\n            if (wrapper && overlayRef.current && shouldScaleBackground) {\n                // Calculate percentageDragged as a fraction (0 to 1)\n                const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);\n                const borderRadiusValue = 8 - percentageDragged * 8;\n                const translateValue = Math.max(0, 14 - percentageDragged * 14);\n                set(wrapper, {\n                    borderRadius: `${borderRadiusValue}px`,\n                    transform: isVertical(direction) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,\n                    transition: 'none'\n                }, true);\n            }\n            if (!snapPoints) {\n                const translateValue = absDraggedDistance * directionMultiplier;\n                set(drawerRef.current, {\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n            }\n        }\n    }\n    React__default.useEffect(()=>{\n        return ()=>{\n            scaleBackground(false);\n            restorePositionSetting();\n        };\n    }, []);\n    React__default.useEffect(()=>{\n        var _window_visualViewport;\n        function onVisualViewportChange() {\n            if (!drawerRef.current) return;\n            const focusedElement = document.activeElement;\n            if (isInput(focusedElement) || keyboardIsOpen.current) {\n                var _window_visualViewport;\n                const visualViewportHeight = ((_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.height) || 0;\n                // This is the height of the keyboard\n                let diffFromInitial = window.innerHeight - visualViewportHeight;\n                const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;\n                if (!initialDrawerHeight.current) {\n                    initialDrawerHeight.current = drawerHeight;\n                }\n                const offsetFromTop = drawerRef.current.getBoundingClientRect().top;\n                // visualViewport height may change due to some subtle changes to the keyboard. Checking if the height changed by 60 or more will make sure that they keyboard really changed its open state.\n                if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {\n                    keyboardIsOpen.current = !keyboardIsOpen.current;\n                }\n                if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {\n                    const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;\n                    diffFromInitial += activeSnapPointHeight;\n                }\n                previousDiffFromInitial.current = diffFromInitial;\n                // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can correctly check if the input is in view\n                if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {\n                    const height = drawerRef.current.getBoundingClientRect().height;\n                    let newDrawerHeight = height;\n                    if (height > visualViewportHeight) {\n                        newDrawerHeight = visualViewportHeight - WINDOW_TOP_OFFSET;\n                    }\n                    // When fixed, don't move the drawer upwards if there's space, but rather only change it's height so it's fully scrollable when the keyboard is open\n                    if (fixed) {\n                        drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;\n                    } else {\n                        drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;\n                    }\n                } else {\n                    drawerRef.current.style.height = `${initialDrawerHeight.current}px`;\n                }\n                if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {\n                    drawerRef.current.style.bottom = `0px`;\n                } else {\n                    // Negative bottom value would never make sense\n                    drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;\n                }\n            }\n        }\n        (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener('resize', onVisualViewportChange);\n        return ()=>{\n            var _window_visualViewport;\n            return (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.removeEventListener('resize', onVisualViewportChange);\n        };\n    }, [\n        activeSnapPointIndex,\n        snapPoints,\n        snapPointsOffset\n    ]);\n    function closeDrawer() {\n        if (!drawerRef.current) return;\n        cancelDrag();\n        onClose == null ? void 0 : onClose();\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `translate3d(0, ${direction === 'bottom' ? '100%' : '-100%'}, 0)` : `translate3d(${direction === 'right' ? '100%' : '-100%'}, 0, 0)`,\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n        });\n        set(overlayRef.current, {\n            opacity: '0',\n            transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n        });\n        scaleBackground(false);\n        setTimeout(()=>{\n            setVisible(false);\n            setIsOpen(false);\n        }, 300);\n        setTimeout(()=>{\n            // reset(document.documentElement, 'scrollBehavior');\n            if (snapPoints) {\n                setActiveSnapPoint(snapPoints[0]);\n            }\n        }, TRANSITIONS.DURATION * 1000); // seconds to ms\n    }\n    React__default.useEffect(()=>{\n        if (!isOpen && shouldScaleBackground) {\n            // Can't use `onAnimationEnd` as the component will be invisible by then\n            const id = setTimeout(()=>{\n                reset(document.body);\n            }, 200);\n            return ()=>clearTimeout(id);\n        }\n    }, [\n        isOpen,\n        shouldScaleBackground\n    ]);\n    // LayoutEffect to prevent extra render where openProp and isOpen are not synced yet\n    React__default.useLayoutEffect(()=>{\n        if (openProp) {\n            setIsOpen(true);\n            setHasBeenOpened(true);\n        } else {\n            closeDrawer();\n        }\n    }, [\n        openProp\n    ]);\n    // This can be done much better\n    React__default.useEffect(()=>{\n        if (mounted) {\n            onOpenChange == null ? void 0 : onOpenChange(isOpen);\n        }\n    }, [\n        isOpen\n    ]);\n    React__default.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    function resetDrawer() {\n        if (!drawerRef.current) return;\n        const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n        const currentSwipeAmount = getTranslate(drawerRef.current, direction);\n        set(drawerRef.current, {\n            transform: 'translate3d(0, 0, 0)',\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n        });\n        set(overlayRef.current, {\n            transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n            opacity: '1'\n        });\n        // Don't reset background if swiped upwards\n        if (shouldScaleBackground && currentSwipeAmount && currentSwipeAmount > 0 && isOpen) {\n            set(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: 'hidden',\n                ...isVertical(direction) ? {\n                    transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                    transformOrigin: 'top'\n                } : {\n                    transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                    transformOrigin: 'left'\n                },\n                transitionProperty: 'transform, border-radius',\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n            }, true);\n        }\n    }\n    function cancelDrag() {\n        if (!isDragging || !drawerRef.current) return;\n        drawerRef.current.classList.remove(DRAG_CLASS);\n        isAllowedToDrag.current = false;\n        setIsDragging(false);\n        dragEndTime.current = new Date();\n    }\n    function onRelease(event) {\n        if (!isDragging || !drawerRef.current) return;\n        drawerRef.current.classList.remove(DRAG_CLASS);\n        isAllowedToDrag.current = false;\n        setIsDragging(false);\n        dragEndTime.current = new Date();\n        const swipeAmount = getTranslate(drawerRef.current, direction);\n        if (!shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount)) return;\n        if (dragStartTime.current === null) return;\n        const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();\n        const distMoved = pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX);\n        const velocity = Math.abs(distMoved) / timeTaken;\n        if (velocity > 0.05) {\n            // `justReleased` is needed to prevent the drawer from focusing on an input when the drag ends, as it's not the intent most of the time.\n            setJustReleased(true);\n            setTimeout(()=>{\n                setJustReleased(false);\n            }, 200);\n        }\n        if (snapPoints) {\n            const directionMultiplier = direction === 'bottom' || direction === 'right' ? 1 : -1;\n            onReleaseSnapPoints({\n                draggedDistance: distMoved * directionMultiplier,\n                closeDrawer,\n                velocity,\n                dismissible\n            });\n            onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n            return;\n        }\n        // Moved upwards, don't do anything\n        if (direction === 'bottom' || direction === 'right' ? distMoved > 0 : distMoved < 0) {\n            resetDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n            return;\n        }\n        if (velocity > VELOCITY_THRESHOLD) {\n            closeDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n            return;\n        }\n        var _drawerRef_current_getBoundingClientRect_height;\n        const visibleDrawerHeight = Math.min((_drawerRef_current_getBoundingClientRect_height = drawerRef.current.getBoundingClientRect().height) != null ? _drawerRef_current_getBoundingClientRect_height : 0, window.innerHeight);\n        if (swipeAmount >= visibleDrawerHeight * closeThreshold) {\n            closeDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n            return;\n        }\n        onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n        resetDrawer();\n    }\n    React__default.useEffect(()=>{\n        // Trigger enter animation without using CSS animation\n        if (isOpen) {\n            set(document.documentElement, {\n                scrollBehavior: 'auto'\n            });\n            openTime.current = new Date();\n            scaleBackground(true);\n        }\n    }, [\n        isOpen\n    ]);\n    React__default.useEffect(()=>{\n        if (drawerRef.current && visible) {\n            var _drawerRef_current;\n            // Find all scrollable elements inside our drawer and assign a class to it so that we can disable overflow when dragging to prevent pointermove not being captured\n            const children = drawerRef == null ? void 0 : (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.querySelectorAll('*');\n            children == null ? void 0 : children.forEach((child)=>{\n                const htmlChild = child;\n                if (htmlChild.scrollHeight > htmlChild.clientHeight || htmlChild.scrollWidth > htmlChild.clientWidth) {\n                    htmlChild.classList.add('vaul-scrollable');\n                }\n            });\n        }\n    }, [\n        visible\n    ]);\n    function scaleBackground(open) {\n        const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n        if (!wrapper || !shouldScaleBackground) return;\n        if (open) {\n            // setting original styles initially\n            set(document.body, {\n                background: document.body.style.backgroundColor || document.body.style.background\n            });\n            // setting body styles, with cache ignored, so that we can get correct original styles in reset\n            set(document.body, {\n                background: 'black'\n            }, true);\n            set(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: 'hidden',\n                ...isVertical(direction) ? {\n                    transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                    transformOrigin: 'top'\n                } : {\n                    transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                    transformOrigin: 'left'\n                },\n                transitionProperty: 'transform, border-radius',\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n            });\n        } else {\n            // Exit\n            reset(wrapper, 'overflow');\n            reset(wrapper, 'transform');\n            reset(wrapper, 'borderRadius');\n            set(wrapper, {\n                transitionProperty: 'transform, border-radius',\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n            });\n        }\n    }\n    function onNestedOpenChange(o) {\n        const scale = o ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;\n        const y = o ? -NESTED_DISPLACEMENT : 0;\n        if (nestedOpenChangeTimer.current) {\n            window.clearTimeout(nestedOpenChangeTimer.current);\n        }\n        set(drawerRef.current, {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n            transform: `scale(${scale}) translate3d(0, ${y}px, 0)`\n        });\n        if (!o && drawerRef.current) {\n            nestedOpenChangeTimer.current = setTimeout(()=>{\n                const translateValue = getTranslate(drawerRef.current, direction);\n                set(drawerRef.current, {\n                    transition: 'none',\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n            }, 500);\n        }\n    }\n    function onNestedDrag(event, percentageDragged) {\n        if (percentageDragged < 0) return;\n        const initialDim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        const initialScale = (initialDim - NESTED_DISPLACEMENT) / initialDim;\n        const newScale = initialScale + percentageDragged * (1 - initialScale);\n        const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,\n            transition: 'none'\n        });\n    }\n    function onNestedRelease(event, o) {\n        const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        const scale = o ? (dim - NESTED_DISPLACEMENT) / dim : 1;\n        const translate = o ? -NESTED_DISPLACEMENT : 0;\n        if (o) {\n            set(drawerRef.current, {\n                transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n                transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`\n            });\n        }\n    }\n    return /*#__PURE__*/ React__default.createElement(DialogPrimitive.Root, {\n        modal: modal,\n        onOpenChange: (o)=>{\n            if (openProp !== undefined) {\n                onOpenChange == null ? void 0 : onOpenChange(o);\n                return;\n            }\n            if (!o) {\n                closeDrawer();\n            } else {\n                setHasBeenOpened(true);\n                setIsOpen(o);\n            }\n        },\n        open: isOpen\n    }, /*#__PURE__*/ React__default.createElement(DrawerContext.Provider, {\n        value: {\n            visible,\n            activeSnapPoint,\n            snapPoints,\n            setActiveSnapPoint,\n            drawerRef,\n            overlayRef,\n            scaleBackground,\n            onOpenChange,\n            onPress,\n            setVisible,\n            onRelease,\n            onDrag,\n            dismissible,\n            isOpen,\n            shouldFade,\n            closeDrawer,\n            onNestedDrag,\n            onNestedOpenChange,\n            onNestedRelease,\n            keyboardIsOpen,\n            openProp,\n            modal,\n            snapPointsOffset,\n            direction\n        }\n    }, children));\n}\nconst Overlay = /*#__PURE__*/ React__default.forwardRef(function({ children, ...rest }, ref) {\n    const { overlayRef, snapPoints, onRelease, shouldFade, isOpen, visible } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, overlayRef);\n    const hasSnapPoints = snapPoints && snapPoints.length > 0;\n    return /*#__PURE__*/ React__default.createElement(DialogPrimitive.Overlay, {\n        onMouseUp: onRelease,\n        ref: composedRef,\n        \"vaul-drawer-visible\": visible ? 'true' : 'false',\n        \"vaul-overlay\": \"\",\n        \"vaul-snap-points\": isOpen && hasSnapPoints ? 'true' : 'false',\n        \"vaul-snap-points-overlay\": isOpen && shouldFade ? 'true' : 'false',\n        ...rest\n    });\n});\nOverlay.displayName = 'Drawer.Overlay';\nconst Content = /*#__PURE__*/ React__default.forwardRef(function({ onOpenAutoFocus, onPointerDownOutside, onAnimationEnd, style, ...rest }, ref) {\n    const { drawerRef, onPress, onRelease, onDrag, dismissible, keyboardIsOpen, snapPointsOffset, visible, closeDrawer, modal, openProp, onOpenChange, setVisible, direction } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, drawerRef);\n    const pointerStartRef = React__default.useRef(null);\n    React__default.useEffect(()=>{\n        // Trigger enter animation without using CSS animation\n        setVisible(true);\n    }, []);\n    const isDeltaInDirection = (delta, direction, threshold = 0)=>{\n        const deltaX = Math.abs(delta.x);\n        const deltaY = Math.abs(delta.y);\n        const isDeltaX = deltaX > deltaY;\n        if (direction === 'left' || direction === 'right') {\n            return isDeltaX && deltaX > threshold;\n        } else {\n            return !isDeltaX && deltaY > threshold;\n        }\n    };\n    return /*#__PURE__*/ React__default.createElement(DialogPrimitive.Content, {\n        \"vaul-drawer\": \"\",\n        \"vaul-drawer-direction\": direction,\n        \"vaul-drawer-visible\": visible ? 'true' : 'false',\n        ...rest,\n        ref: composedRef,\n        style: snapPointsOffset && snapPointsOffset.length > 0 ? {\n            '--snap-point-height': `${snapPointsOffset[0]}px`,\n            ...style\n        } : style,\n        onOpenAutoFocus: (e)=>{\n            if (onOpenAutoFocus) {\n                onOpenAutoFocus(e);\n            } else {\n                var _drawerRef_current;\n                e.preventDefault();\n                (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.focus();\n            }\n        },\n        onPointerDown: (event)=>{\n            rest.onPointerDown == null ? void 0 : rest.onPointerDown.call(rest, event);\n            pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n            };\n            onPress(event);\n        },\n        onPointerDownOutside: (e)=>{\n            onPointerDownOutside == null ? void 0 : onPointerDownOutside(e);\n            if (!modal || e.defaultPrevented) {\n                e.preventDefault();\n                return;\n            }\n            if (keyboardIsOpen.current) {\n                keyboardIsOpen.current = false;\n            }\n            e.preventDefault();\n            onOpenChange == null ? void 0 : onOpenChange(false);\n            if (!dismissible || openProp !== undefined) {\n                return;\n            }\n            closeDrawer();\n        },\n        onPointerMove: (event)=>{\n            rest.onPointerMove == null ? void 0 : rest.onPointerMove.call(rest, event);\n            if (!pointerStartRef.current) return null;\n            const yPosition = event.clientY - pointerStartRef.current.y;\n            const xPosition = event.clientX - pointerStartRef.current.x;\n            const isHorizontalSwipe = [\n                'left',\n                'right'\n            ].includes(direction);\n            const clamp = [\n                'left',\n                'top'\n            ].includes(direction) ? Math.min : Math.max;\n            const clampedX = isHorizontalSwipe ? clamp(0, xPosition) : 0;\n            const clampedY = !isHorizontalSwipe ? clamp(0, yPosition) : 0;\n            const swipeStartThreshold = event.pointerType === 'touch' ? 10 : 2;\n            const delta = {\n                x: clampedX,\n                y: clampedY\n            };\n            const isAllowedToSwipe = isDeltaInDirection(delta, direction, swipeStartThreshold);\n            if (isAllowedToSwipe) onDrag(event);\n            else if (Math.abs(xPosition) > swipeStartThreshold || Math.abs(yPosition) > swipeStartThreshold) {\n                pointerStartRef.current = null;\n            }\n        },\n        onPointerUp: (event)=>{\n            rest.onPointerUp == null ? void 0 : rest.onPointerUp.call(rest, event);\n            pointerStartRef.current = null;\n            onRelease(event);\n        }\n    });\n});\nContent.displayName = 'Drawer.Content';\nfunction NestedRoot({ onDrag, onOpenChange, ...rest }) {\n    const { onNestedDrag, onNestedOpenChange, onNestedRelease } = useDrawerContext();\n    if (!onNestedDrag) {\n        throw new Error('Drawer.NestedRoot must be placed in another drawer');\n    }\n    return /*#__PURE__*/ React__default.createElement(Root, {\n        nested: true,\n        onClose: ()=>{\n            onNestedOpenChange(false);\n        },\n        onDrag: (e, p)=>{\n            onNestedDrag(e, p);\n            onDrag == null ? void 0 : onDrag(e, p);\n        },\n        onOpenChange: (o)=>{\n            if (o) {\n                onNestedOpenChange(o);\n            }\n            onOpenChange == null ? void 0 : onOpenChange(o);\n        },\n        onRelease: onNestedRelease,\n        ...rest\n    });\n}\nconst Drawer = {\n    Root,\n    NestedRoot,\n    Content,\n    Overlay,\n    Trigger: DialogPrimitive.Trigger,\n    Portal: DialogPrimitive.Portal,\n    Close: DialogPrimitive.Close,\n    Title: DialogPrimitive.Title,\n    Description: DialogPrimitive.Description\n};\n\nexport { Drawer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}