{"version":3,"sources":["../../../../../src/components/Form/Multiselect/hooks/useMultiselectInput.ts"],"sourcesContent":["'use client';\n\nimport { ChangeEvent, useCallback, useRef, useState } from 'react';\n\nimport { useCustomEnsuredControl } from 'hooks/useEnsureControl';\n\nimport { MultiselectOption, MultiselectOptionValue } from '../types';\nimport { getNewOptionData } from './helpers/getNewOptionData';\nimport { isValueLikeOption } from './helpers/isValueLikeOption';\nimport { simulateReactInput } from './helpers/simulateReactInput';\n\nexport interface UseMultiselectInputProps {\n  /** If true, the multiselect is considered disabled and cannot be interacted with. */\n  disabled?: boolean;\n  /** The currently selected options. */\n  value: MultiselectOption[];\n  /** The default value(s) for the multiselect if `value` is uncontrolled. */\n  defaultValue?: MultiselectOption[];\n  /** Callback fired when the selected options change. */\n  onChange?: (options: MultiselectOption[]) => void;\n  /** The current value of the input field, for controlling component behavior. */\n  inputValue?: string;\n  /** Callback fired when the input value changes. */\n  onInputChange?: (event: ChangeEvent<HTMLInputElement>) => void;\n}\n\n/**\n * Hook for managing the state and interactions of a multiselect input component.\n * It handles adding and removing options, input changes, and input clearing functionalities.\n */\nexport const useMultiselectInput = ({\n  disabled,\n  value: valueProp,\n  onChange,\n  defaultValue = [],\n  inputValue: inputValueProp = '',\n  onInputChange,\n}: UseMultiselectInputProps) => {\n  const [value, setValue] = useCustomEnsuredControl({\n    value: valueProp,\n    disabled,\n    defaultValue,\n    onChange,\n  });\n\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [inputValue, setInputValue] = useState(inputValueProp);\n\n  const toggleOption = useCallback((nextValueProp: MultiselectOption | MultiselectOptionValue, isNewValue: boolean) => {\n    let valueForChange = valueProp;\n\n    setValue((prevValue) => {\n      const isLikeOption = isValueLikeOption(nextValueProp);\n      const resolvedOption = isLikeOption\n        ? getNewOptionData(nextValueProp.value, nextValueProp.label)\n        : getNewOptionData(nextValueProp, typeof nextValueProp === 'string' ? nextValueProp : '');\n      const nextValue = prevValue.filter((option) => resolvedOption.value !== option.value);\n\n      if (isNewValue) {\n        nextValue.push(isLikeOption ? {\n          ...nextValueProp,\n          ...resolvedOption,\n        } : resolvedOption);\n      }\n\n      valueForChange = nextValue;\n      return nextValue;\n    });\n\n    onChange?.(valueForChange);\n  }, [setValue]);\n\n  const clearInput = useCallback(() => {\n    simulateReactInput(inputRef.current!, '');\n  }, [inputRef]);\n\n  const addOption = useCallback(\n    (newValue: MultiselectOption | MultiselectOptionValue) => toggleOption(newValue, true),\n    [toggleOption],\n  );\n\n  const removeOption = useCallback((newValue: MultiselectOption | MultiselectOptionValue) => {\n    toggleOption(newValue, false);\n  }, [toggleOption]);\n\n  const addOptionFromInput = useCallback((inputValueToAdd: string) => {\n    const label = inputValueToAdd.trim();\n\n    if (!label) {\n      return;\n    }\n\n    addOption(label);\n    clearInput();\n  }, [addOption, clearInput]);\n\n  const inputChange = useCallback((event: ChangeEvent<HTMLInputElement>) => {\n    setInputValue(event.currentTarget.value);\n    onInputChange?.(event);\n  }, [onInputChange]);\n\n  return {\n    value,\n    addOption,\n    addOptionFromInput,\n    removeOption,\n\n    inputRef,\n    inputValue,\n    onInputChange: inputChange,\n    clearInput,\n  };\n};\n"],"names":["useCallback","useRef","useState","useCustomEnsuredControl","getNewOptionData","isValueLikeOption","simulateReactInput","useMultiselectInput","disabled","value","valueProp","onChange","defaultValue","inputValue","inputValueProp","onInputChange","setValue","inputRef","setInputValue","toggleOption","nextValueProp","isNewValue","valueForChange","prevValue","isLikeOption","resolvedOption","label","nextValue","filter","option","push","clearInput","current","addOption","newValue","removeOption","addOptionFromInput","inputValueToAdd","trim","inputChange","event","currentTarget"],"mappings":"AAAA;;AAEA,SAAsBA,WAAW,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,QAAQ;AAEnE,SAASC,uBAAuB,QAAQ,qCAAyB;AAGjE,SAASC,gBAAgB,QAAQ,6BAA6B;AAC9D,SAASC,iBAAiB,QAAQ,8BAA8B;AAChE,SAASC,kBAAkB,QAAQ,+BAA+B;AAiBlE;;;CAGC,GACD,OAAO,MAAMC,sBAAsB,CAAC,EAClCC,QAAQ,EACRC,OAAOC,SAAS,EAChBC,QAAQ,EACRC,eAAe,EAAE,EACjBC,YAAYC,iBAAiB,EAAE,EAC/BC,aAAa,EACY;IACzB,MAAM,CAACN,OAAOO,SAAS,GAAGb,wBAAwB;QAChDM,OAAOC;QACPF;QACAI;QACAD;IACF;IAEA,MAAMM,WAAWhB,OAAyB;IAC1C,MAAM,CAACY,YAAYK,cAAc,GAAGhB,SAASY;IAE7C,MAAMK,eAAenB,YAAY,CAACoB,eAA2DC;QAC3F,IAAIC,iBAAiBZ;QAErBM,SAAS,CAACO;YACR,MAAMC,eAAenB,kBAAkBe;YACvC,MAAMK,iBAAiBD,eACnBpB,iBAAiBgB,cAAcX,KAAK,EAAEW,cAAcM,KAAK,IACzDtB,iBAAiBgB,eAAe,OAAOA,kBAAkB,WAAWA,gBAAgB;YACxF,MAAMO,YAAYJ,UAAUK,MAAM,CAAC,CAACC,SAAWJ,eAAehB,KAAK,KAAKoB,OAAOpB,KAAK;YAEpF,IAAIY,YAAY;gBACdM,UAAUG,IAAI,CAACN,eAAe,mBACzBJ,eACAK,kBACDA;YACN;YAEAH,iBAAiBK;YACjB,OAAOA;QACT;QAEAhB,qBAAAA,+BAAAA,SAAWW;IACb,GAAG;QAACN;KAAS;IAEb,MAAMe,aAAa/B,YAAY;QAC7BM,mBAAmBW,SAASe,OAAO,EAAG;IACxC,GAAG;QAACf;KAAS;IAEb,MAAMgB,YAAYjC,YAChB,CAACkC,WAAyDf,aAAae,UAAU,OACjF;QAACf;KAAa;IAGhB,MAAMgB,eAAenC,YAAY,CAACkC;QAChCf,aAAae,UAAU;IACzB,GAAG;QAACf;KAAa;IAEjB,MAAMiB,qBAAqBpC,YAAY,CAACqC;QACtC,MAAMX,QAAQW,gBAAgBC,IAAI;QAElC,IAAI,CAACZ,OAAO;YACV;QACF;QAEAO,UAAUP;QACVK;IACF,GAAG;QAACE;QAAWF;KAAW;IAE1B,MAAMQ,cAAcvC,YAAY,CAACwC;QAC/BtB,cAAcsB,MAAMC,aAAa,CAAChC,KAAK;QACvCM,0BAAAA,oCAAAA,cAAgByB;IAClB,GAAG;QAACzB;KAAc;IAElB,OAAO;QACLN;QACAwB;QACAG;QACAD;QAEAlB;QACAJ;QACAE,eAAewB;QACfR;IACF;AACF,EAAE"}