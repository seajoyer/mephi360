{"version":3,"sources":["../../../../../src/components/Form/Slider/hooks/useSlider.ts"],"sourcesContent":["'use client';\n\nimport { ChangeEvent, useMemo, useRef, useState } from 'react';\n\nimport { isEqual } from 'helpers/equal';\nimport { clamp } from 'helpers/math';\n\nimport { SliderProps } from 'components/Form/Slider/Slider';\nimport type { TouchEvent } from 'components/Service/Touch/Touch';\nimport { extractSliderAriaAttributes, getDraggingTypeByTargetDataset } from './helpers/html';\nimport { offsetXToScaledValue, toPercent } from './helpers/math';\nimport {\n  determineSnapDirection,\n  isMultipleValues,\n  updateInternalStateByNativeChange,\n  updateInternalStateValue,\n} from './helpers/state';\nimport { InternalGestureRef, InternalValueState, Step } from './types';\n\nexport const useSlider = ({\n  step = 1,\n  min = 0,\n  max = 100,\n  value: valueProp,\n  multiple: multipleProp,\n  defaultValue = multipleProp ? [min, max] : min,\n  disabled,\n  getAriaLabel,\n  getAriaValueText,\n  onChange,\n  ...restProps\n}: SliderProps) => {\n  const isControlled = valueProp !== undefined;\n  const [localValue, setValue] = useState(defaultValue);\n\n  const value = useMemo<InternalValueState>(() => {\n    const resolvedValue = isControlled ? valueProp : localValue;\n\n    return Array.isArray(resolvedValue)\n      ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)]\n      : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n\n  const [startValue, endValue] = value;\n  const multiple = multipleProp && endValue !== null;\n\n  const gesture = useRef<InternalGestureRef>({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0,\n  }).current;\n\n  const thumbsContainerRef = useRef<HTMLDivElement>(null);\n  const thumbStartInputRef = useRef<HTMLInputElement>(null);\n  const thumbEndInputRef = useRef<HTMLInputElement>(null);\n\n  const changeValue = (nextValue: InternalValueState, event: TouchEvent | ChangeEvent) => {\n    if (disabled || isEqual(nextValue[0], nextValue[1])) {\n      return;\n    }\n\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n\n  const handlePointerStart = (event: TouchEvent) => {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n\n    const { left: nextContainerX, width: nextContainerWidth } =\n      thumbsContainerRef.current.getBoundingClientRect();\n\n    if (!(event.originalEvent.target instanceof HTMLElement)) {\n      return;\n    }\n\n    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n    const nextStartX = event.startX - nextContainerX;\n    const nextValue = offsetXToScaledValue(nextStartX, nextContainerWidth, min, max, step);\n    const nextDragging = determineSnapDirection(value, nextValue, foundDraggingType);\n\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n\n    const updatedInternalStateValue = updateInternalStateValue(\n      value,\n      nextValue,\n      min,\n      max,\n      nextDragging,\n    );\n\n    const [nextStartValue, nextEndValue] = updatedInternalStateValue;\n    if (\n      thumbStartInputRef.current &&\n      (foundDraggingType === 'start' || (nextStartValue !== startValue && nextEndValue === endValue))\n    ) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (\n      thumbEndInputRef.current &&\n      (foundDraggingType === 'end' || (nextEndValue !== endValue && nextStartValue === startValue))\n    ) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n\n    changeValue(updatedInternalStateValue, event);\n    event.originalEvent.stopPropagation();\n  };\n\n  const handlePointerMove = (event: TouchEvent) => {\n    const { startX, containerWidth, dragging } = gesture;\n\n    const { shiftX = 0 } = event;\n    const nextStartX = startX + shiftX;\n    const nextValue = offsetXToScaledValue(nextStartX, containerWidth, min, max, step);\n\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const handlePointerEnd = (event: TouchEvent) => {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n  };\n\n  const handleChangeByNativeInput = (event: ChangeEvent<HTMLInputElement>) => {\n    changeValue(\n      updateInternalStateByNativeChange(\n        value,\n        Number(event.target.value),\n        getDraggingTypeByTargetDataset(event.target),\n      ),\n      event,\n    );\n  };\n\n  const { aria, ...restPropsWithoutArea } = extractSliderAriaAttributes(restProps);\n  const getInputProps = (isEndInput: boolean) => {\n    const index = isEndInput ? 1 : 0;\n    return {\n      'data-type': isEndInput ? 'end' : 'start',\n      step,\n      min,\n      value: isEndInput && multiple ? endValue : startValue,\n      max: !isEndInput && multiple ? endValue : max,\n      disabled,\n      'aria-label': getAriaLabel ? getAriaLabel(index) : aria.ariaLabel,\n      'aria-valuetext': getAriaValueText ? getAriaValueText(startValue, index) : aria.ariaValueText,\n      'aria-labelledby': aria.ariaLabelledBy,\n      onChange: handleChangeByNativeInput,\n    };\n  };\n\n  const getStepsCoordinates = () => {\n    if (step === 1) {\n      return undefined;\n    }\n\n    const steps: Step[] = [];\n    const stepsCount = Math.floor((max - min) / step);\n\n    for (let i = 0; i <= stepsCount; i += 1) {\n      const stepValue = min + i * step;\n\n      const isPassed = multiple\n        ? stepValue >= startValue && stepValue <= endValue\n        : stepValue <= startValue;\n\n      steps.push({\n        isPassed,\n        XCoordinate: toPercent(stepValue, min, max),\n      });\n    }\n\n    return steps;\n  };\n\n  return {\n    steps: getStepsCoordinates(),\n    multiple,\n    containerProps: restPropsWithoutArea,\n    startValueInPercent: toPercent(startValue, min, max),\n    endReversedValueInPercent: multiple ? toPercent(endValue, min, max) : 0,\n    thumbsContainerRef,\n    thumbStartInputRef,\n    thumbEndInputRef,\n    handlePointerStart,\n    handlePointerMove,\n    handlePointerEnd,\n    getInputProps,\n  };\n};\n"],"names":["useMemo","useRef","useState","isEqual","clamp","extractSliderAriaAttributes","getDraggingTypeByTargetDataset","offsetXToScaledValue","toPercent","determineSnapDirection","isMultipleValues","updateInternalStateByNativeChange","updateInternalStateValue","useSlider","step","min","max","value","valueProp","multiple","multipleProp","defaultValue","disabled","getAriaLabel","getAriaValueText","onChange","restProps","isControlled","undefined","localValue","setValue","resolvedValue","Array","isArray","startValue","endValue","gesture","dragging","startX","containerWidth","current","thumbsContainerRef","thumbStartInputRef","thumbEndInputRef","changeValue","nextValue","event","handlePointerStart","left","nextContainerX","width","nextContainerWidth","getBoundingClientRect","originalEvent","target","HTMLElement","foundDraggingType","nextStartX","nextDragging","updatedInternalStateValue","nextStartValue","nextEndValue","focus","preventDefault","stopPropagation","handlePointerMove","shiftX","handlePointerEnd","handleChangeByNativeInput","Number","aria","restPropsWithoutArea","getInputProps","isEndInput","index","ariaLabel","ariaValueText","ariaLabelledBy","getStepsCoordinates","steps","stepsCount","Math","floor","i","stepValue","isPassed","push","XCoordinate","containerProps","startValueInPercent","endReversedValueInPercent"],"mappings":"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"}