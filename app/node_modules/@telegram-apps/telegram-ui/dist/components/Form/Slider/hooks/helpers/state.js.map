{"version":3,"sources":["../../../../../../src/components/Form/Slider/hooks/helpers/state.ts"],"sourcesContent":["import { clamp } from 'helpers/math';\n\nimport type { InternalDraggingType, InternalValueState } from '../types';\n\nexport const updateInternalStateValue = (\n  currentState: InternalValueState,\n  newValue: number,\n  minValue: number,\n  maxValue: number,\n  draggingType: InternalDraggingType | null,\n): InternalValueState => {\n  const [currentStartValue, currentEndValue] = currentState;\n\n  if (currentEndValue === null) {\n    return [clamp(newValue, minValue, maxValue), null];\n  }\n\n  switch (draggingType) {\n    case 'start':\n      return newValue > currentEndValue\n        ? [currentEndValue, currentEndValue]\n        : [clamp(newValue, minValue, maxValue), currentEndValue];\n    case 'end':\n      return newValue < currentStartValue\n        ? [currentStartValue, currentStartValue]\n        : [currentStartValue, clamp(newValue, minValue, maxValue)];\n    case null:\n    default:\n      return currentState;\n  }\n};\n\nexport const updateInternalStateByNativeChange = (\n  currentState: InternalValueState,\n  newValue: number,\n  draggingType: InternalDraggingType | null,\n): InternalValueState => {\n  const [currentStartValue, currentEndValue] = currentState;\n  switch (draggingType) {\n    case 'start':\n      return [newValue, currentEndValue];\n    case 'end':\n      return [currentStartValue, newValue];\n    case null:\n    default:\n      return currentState;\n  }\n};\n\nexport const isMultipleValues = (value: InternalValueState): value is [number, number] => {\n  return value[1] !== null;\n};\n\nconst MINIMUM_DIFFERENCE_BETWEEN_START_AND_END = 0.1;\n\nexport const determineSnapDirection = (\n  currentValues: InternalValueState,\n  newValue: number,\n  draggingType: InternalDraggingType | null,\n): InternalDraggingType | null => {\n  if (draggingType === 'start' || draggingType === 'end') {\n    return draggingType;\n  }\n\n  const [startRaw, endRaw] = currentValues;\n  const start = endRaw !== null ? startRaw - MINIMUM_DIFFERENCE_BETWEEN_START_AND_END : startRaw;\n  const end = endRaw !== null ? endRaw + MINIMUM_DIFFERENCE_BETWEEN_START_AND_END : 0;\n\n  return Math.abs(start - newValue) <= Math.abs(end - newValue) ? 'start' : 'end';\n};\n"],"names":["clamp","updateInternalStateValue","currentState","newValue","minValue","maxValue","draggingType","currentStartValue","currentEndValue","updateInternalStateByNativeChange","isMultipleValues","value","MINIMUM_DIFFERENCE_BETWEEN_START_AND_END","determineSnapDirection","currentValues","startRaw","endRaw","start","end","Math","abs"],"mappings":"AAAA,SAASA,KAAK,QAAQ,8BAAe;AAIrC,OAAO,MAAMC,2BAA2B,CACtCC,cACAC,UACAC,UACAC,UACAC;IAEA,MAAM,CAACC,mBAAmBC,gBAAgB,GAAGN;IAE7C,IAAIM,oBAAoB,MAAM;QAC5B,OAAO;YAACR,MAAMG,UAAUC,UAAUC;YAAW;SAAK;IACpD;IAEA,OAAQC;QACN,KAAK;YACH,OAAOH,WAAWK,kBACd;gBAACA;gBAAiBA;aAAgB,GAClC;gBAACR,MAAMG,UAAUC,UAAUC;gBAAWG;aAAgB;QAC5D,KAAK;YACH,OAAOL,WAAWI,oBACd;gBAACA;gBAAmBA;aAAkB,GACtC;gBAACA;gBAAmBP,MAAMG,UAAUC,UAAUC;aAAU;QAC9D,KAAK;QACL;YACE,OAAOH;IACX;AACF,EAAE;AAEF,OAAO,MAAMO,oCAAoC,CAC/CP,cACAC,UACAG;IAEA,MAAM,CAACC,mBAAmBC,gBAAgB,GAAGN;IAC7C,OAAQI;QACN,KAAK;YACH,OAAO;gBAACH;gBAAUK;aAAgB;QACpC,KAAK;YACH,OAAO;gBAACD;gBAAmBJ;aAAS;QACtC,KAAK;QACL;YACE,OAAOD;IACX;AACF,EAAE;AAEF,OAAO,MAAMQ,mBAAmB,CAACC;IAC/B,OAAOA,KAAK,CAAC,EAAE,KAAK;AACtB,EAAE;AAEF,MAAMC,2CAA2C;AAEjD,OAAO,MAAMC,yBAAyB,CACpCC,eACAX,UACAG;IAEA,IAAIA,iBAAiB,WAAWA,iBAAiB,OAAO;QACtD,OAAOA;IACT;IAEA,MAAM,CAACS,UAAUC,OAAO,GAAGF;IAC3B,MAAMG,QAAQD,WAAW,OAAOD,WAAWH,2CAA2CG;IACtF,MAAMG,MAAMF,WAAW,OAAOA,SAASJ,2CAA2C;IAElF,OAAOO,KAAKC,GAAG,CAACH,QAAQd,aAAagB,KAAKC,GAAG,CAACF,MAAMf,YAAY,UAAU;AAC5E,EAAE"}