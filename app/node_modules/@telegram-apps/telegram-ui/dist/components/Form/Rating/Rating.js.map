{"version":3,"sources":["../../../../src/components/Form/Rating/Rating.tsx"],"sourcesContent":["import { ChangeEvent, ElementType, HTMLAttributes } from 'react';\nimport styles from './Rating.module.css';\n\nimport { clamp } from 'helpers/math';\nimport { useCustomEnsuredControl } from 'hooks/useEnsureControl';\nimport { Icon } from 'types/Icon';\n\nimport { VisuallyHidden } from 'components/Service/VisuallyHidden/VisuallyHidden';\nimport { IconStar } from './icons/star';\n\nexport interface RatingProps extends Omit<HTMLAttributes<HTMLLabelElement>, 'onChange'> {\n  /** The precision of the rating, determining the fraction of the star that can be selected. */\n  precision?: 0.1 | 0.2 | 0.25 | 0.5 | 1;\n  /** The maximum rating value, representing the number of icons displayed. */\n  max?: number;\n  /** The current value of the rating. */\n  value?: number;\n  /** Callback function invoked when the rating value changes. */\n  onChange?: (value: number) => void;\n  /** The component used to render the rating icons. Defaults to a star icon. */\n  IconContainer?: ElementType<Icon>;\n}\n\nconst MINIMUM_PRECISION = 0.1;\n\n/**\n * Renders a customizable rating component, allowing users to provide a rating by selecting a value using icons (e.g., stars).\n * Supports fractional ratings through precision control and allows for custom rating icon components.\n */\nexport const Rating = ({\n  precision = 1,\n  max = 5,\n  onChange,\n  value: valueProp = 0,\n  IconContainer = IconStar,\n}: RatingProps) => {\n  const [value, setValue] = useCustomEnsuredControl({\n    defaultValue: valueProp,\n    onChange,\n  });\n\n  const normalizedPrecision = clamp(precision, MINIMUM_PRECISION, 1);\n\n  const onChangeLabel = (event: ChangeEvent<HTMLLabelElement>) => {\n    const { target } = event;\n    if (target instanceof HTMLInputElement) {\n      setValue(parseFloat(target.value));\n    }\n  };\n\n  const getPickedElementWidth = (elementNumber: number): number | undefined => {\n    if (elementNumber <= value) {\n      return 1;\n    }\n\n    const valueRange = elementNumber - value;\n    if (valueRange > 0 && valueRange < 1) {\n      return 1 - valueRange;\n    }\n\n    return undefined;\n  };\n\n  const keys = Array.from(Array(max).keys());\n  return (\n    <label className={styles.wrapper} onChange={onChangeLabel}>\n      <VisuallyHidden Component=\"input\" name=\"rating\" type=\"radio\" value={0} />\n      {keys.map((key) => {\n        const elementsWithPrecision = Math.floor(1 / normalizedPrecision);\n        const elements = Array.from(Array(elementsWithPrecision).keys());\n\n        const pickedElementWidth = getPickedElementWidth(key + 1);\n        return (\n          <label key={key} className={styles.element}>\n            {pickedElementWidth !== undefined && (\n              <IconContainer\n                key=\"star-picked\"\n                className={styles['element--picked']}\n                style={{ width: `${pickedElementWidth * 100}%` }}\n              />\n            )}\n            <IconContainer key=\"star\" />\n            {elements.map((element) => (\n              <input\n                key={element}\n                type=\"radio\"\n                value={(key + (element + 1) * normalizedPrecision).toFixed(1)}\n                name=\"rating\"\n                style={{\n                  width: `${normalizedPrecision * 100}%`,\n                  left: `${element * normalizedPrecision * 100}%`,\n                }}\n                className={styles.input}\n              />\n            ))}\n          </label>\n        );\n      })}\n    </label>\n  );\n};\n"],"names":["clamp","useCustomEnsuredControl","VisuallyHidden","IconStar","MINIMUM_PRECISION","Rating","precision","max","onChange","value","valueProp","IconContainer","setValue","defaultValue","normalizedPrecision","onChangeLabel","event","target","HTMLInputElement","parseFloat","getPickedElementWidth","elementNumber","valueRange","undefined","keys","Array","from","label","className","Component","name","type","map","key","elementsWithPrecision","Math","floor","elements","pickedElementWidth","style","width","element","input","toFixed","left"],"mappings":";AAGA,SAASA,KAAK,QAAQ,wBAAe;AACrC,SAASC,uBAAuB,QAAQ,kCAAyB;AAGjE,SAASC,cAAc,QAAQ,8CAAmD;AAClF,SAASC,QAAQ,QAAQ,eAAe;AAexC,MAAMC,oBAAoB;AAE1B;;;CAGC,GACD,OAAO,MAAMC,SAAS,CAAC,EACrBC,YAAY,CAAC,EACbC,MAAM,CAAC,EACPC,QAAQ,EACRC,OAAOC,YAAY,CAAC,EACpBC,gBAAgBR,QAAQ,EACZ;IACZ,MAAM,CAACM,OAAOG,SAAS,GAAGX,wBAAwB;QAChDY,cAAcH;QACdF;IACF;IAEA,MAAMM,sBAAsBd,MAAMM,WAAWF,mBAAmB;IAEhE,MAAMW,gBAAgB,CAACC;QACrB,MAAM,EAAEC,MAAM,EAAE,GAAGD;QACnB,IAAIC,kBAAkBC,kBAAkB;YACtCN,SAASO,WAAWF,OAAOR,KAAK;QAClC;IACF;IAEA,MAAMW,wBAAwB,CAACC;QAC7B,IAAIA,iBAAiBZ,OAAO;YAC1B,OAAO;QACT;QAEA,MAAMa,aAAaD,gBAAgBZ;QACnC,IAAIa,aAAa,KAAKA,aAAa,GAAG;YACpC,OAAO,IAAIA;QACb;QAEA,OAAOC;IACT;IAEA,MAAMC,OAAOC,MAAMC,IAAI,CAACD,MAAMlB,KAAKiB,IAAI;IACvC,qBACE,MAACG;QAAMC,SAAS;QAAkBpB,UAAUO;;0BAC1C,KAACb;gBAAe2B,WAAU;gBAAQC,MAAK;gBAASC,MAAK;gBAAQtB,OAAO;;YACnEe,KAAKQ,GAAG,CAAC,CAACC;gBACT,MAAMC,wBAAwBC,KAAKC,KAAK,CAAC,IAAItB;gBAC7C,MAAMuB,WAAWZ,MAAMC,IAAI,CAACD,MAAMS,uBAAuBV,IAAI;gBAE7D,MAAMc,qBAAqBlB,sBAAsBa,MAAM;gBACvD,qBACE,MAACN;oBAAgBC,SAAS;;wBACvBU,uBAAuBf,2BACtB,KAACZ;4BAECiB,SAAS;4BACTW,OAAO;gCAAEC,OAAO,CAAC,EAAEF,qBAAqB,IAAI,CAAC,CAAC;4BAAC;2BAF3C;sCAKR,KAAC3B,mBAAkB;wBAClB0B,SAASL,GAAG,CAAC,CAACS,wBACb,KAACC;gCAECX,MAAK;gCACLtB,OAAO,AAACwB,CAAAA,MAAM,AAACQ,CAAAA,UAAU,CAAA,IAAK3B,mBAAkB,EAAG6B,OAAO,CAAC;gCAC3Db,MAAK;gCACLS,OAAO;oCACLC,OAAO,CAAC,EAAE1B,sBAAsB,IAAI,CAAC,CAAC;oCACtC8B,MAAM,CAAC,EAAEH,UAAU3B,sBAAsB,IAAI,CAAC,CAAC;gCACjD;gCACAc,SAAS;+BARJa;;mBAXCR;YAwBhB;;;AAGN,EAAE"}