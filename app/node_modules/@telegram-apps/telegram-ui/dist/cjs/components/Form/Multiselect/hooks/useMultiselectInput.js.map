{"version":3,"sources":["../../../../../../src/components/Form/Multiselect/hooks/useMultiselectInput.ts"],"sourcesContent":["'use client';\n\nimport { ChangeEvent, useCallback, useRef, useState } from 'react';\n\nimport { useCustomEnsuredControl } from 'hooks/useEnsureControl';\n\nimport { MultiselectOption, MultiselectOptionValue } from '../types';\nimport { getNewOptionData } from './helpers/getNewOptionData';\nimport { isValueLikeOption } from './helpers/isValueLikeOption';\nimport { simulateReactInput } from './helpers/simulateReactInput';\n\nexport interface UseMultiselectInputProps {\n  /** If true, the multiselect is considered disabled and cannot be interacted with. */\n  disabled?: boolean;\n  /** The currently selected options. */\n  value: MultiselectOption[];\n  /** The default value(s) for the multiselect if `value` is uncontrolled. */\n  defaultValue?: MultiselectOption[];\n  /** Callback fired when the selected options change. */\n  onChange?: (options: MultiselectOption[]) => void;\n  /** The current value of the input field, for controlling component behavior. */\n  inputValue?: string;\n  /** Callback fired when the input value changes. */\n  onInputChange?: (event: ChangeEvent<HTMLInputElement>) => void;\n}\n\n/**\n * Hook for managing the state and interactions of a multiselect input component.\n * It handles adding and removing options, input changes, and input clearing functionalities.\n */\nexport const useMultiselectInput = ({\n  disabled,\n  value: valueProp,\n  onChange,\n  defaultValue = [],\n  inputValue: inputValueProp = '',\n  onInputChange,\n}: UseMultiselectInputProps) => {\n  const [value, setValue] = useCustomEnsuredControl({\n    value: valueProp,\n    disabled,\n    defaultValue,\n    onChange,\n  });\n\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [inputValue, setInputValue] = useState(inputValueProp);\n\n  const toggleOption = useCallback((nextValueProp: MultiselectOption | MultiselectOptionValue, isNewValue: boolean) => {\n    let valueForChange = valueProp;\n\n    setValue((prevValue) => {\n      const isLikeOption = isValueLikeOption(nextValueProp);\n      const resolvedOption = isLikeOption\n        ? getNewOptionData(nextValueProp.value, nextValueProp.label)\n        : getNewOptionData(nextValueProp, typeof nextValueProp === 'string' ? nextValueProp : '');\n      const nextValue = prevValue.filter((option) => resolvedOption.value !== option.value);\n\n      if (isNewValue) {\n        nextValue.push(isLikeOption ? {\n          ...nextValueProp,\n          ...resolvedOption,\n        } : resolvedOption);\n      }\n\n      valueForChange = nextValue;\n      return nextValue;\n    });\n\n    onChange?.(valueForChange);\n  }, [setValue]);\n\n  const clearInput = useCallback(() => {\n    simulateReactInput(inputRef.current!, '');\n  }, [inputRef]);\n\n  const addOption = useCallback(\n    (newValue: MultiselectOption | MultiselectOptionValue) => toggleOption(newValue, true),\n    [toggleOption],\n  );\n\n  const removeOption = useCallback((newValue: MultiselectOption | MultiselectOptionValue) => {\n    toggleOption(newValue, false);\n  }, [toggleOption]);\n\n  const addOptionFromInput = useCallback((inputValueToAdd: string) => {\n    const label = inputValueToAdd.trim();\n\n    if (!label) {\n      return;\n    }\n\n    addOption(label);\n    clearInput();\n  }, [addOption, clearInput]);\n\n  const inputChange = useCallback((event: ChangeEvent<HTMLInputElement>) => {\n    setInputValue(event.currentTarget.value);\n    onInputChange?.(event);\n  }, [onInputChange]);\n\n  return {\n    value,\n    addOption,\n    addOptionFromInput,\n    removeOption,\n\n    inputRef,\n    inputValue,\n    onInputChange: inputChange,\n    clearInput,\n  };\n};\n"],"names":["useMultiselectInput","disabled","value","valueProp","onChange","defaultValue","inputValue","inputValueProp","onInputChange","setValue","useCustomEnsuredControl","inputRef","useRef","setInputValue","useState","toggleOption","useCallback","nextValueProp","isNewValue","valueForChange","prevValue","isLikeOption","isValueLikeOption","resolvedOption","getNewOptionData","label","nextValue","filter","option","push","clearInput","simulateReactInput","current","addOption","newValue","removeOption","addOptionFromInput","inputValueToAdd","trim","inputChange","event","currentTarget"],"mappings":"AAAA;;;;;+BA8BaA;;;eAAAA;;;;uBA5B8C;kCAEnB;kCAGP;mCACC;oCACC;AAqB5B,MAAMA,sBAAsB,CAAC,EAClCC,QAAQ,EACRC,OAAOC,SAAS,EAChBC,QAAQ,EACRC,eAAe,EAAE,EACjBC,YAAYC,iBAAiB,EAAE,EAC/BC,aAAa,EACY;IACzB,MAAM,CAACN,OAAOO,SAAS,GAAGC,IAAAA,yCAAuB,EAAC;QAChDR,OAAOC;QACPF;QACAI;QACAD;IACF;IAEA,MAAMO,WAAWC,IAAAA,aAAM,EAAmB;IAC1C,MAAM,CAACN,YAAYO,cAAc,GAAGC,IAAAA,eAAQ,EAACP;IAE7C,MAAMQ,eAAeC,IAAAA,kBAAW,EAAC,CAACC,eAA2DC;QAC3F,IAAIC,iBAAiBhB;QAErBM,SAAS,CAACW;YACR,MAAMC,eAAeC,IAAAA,oCAAiB,EAACL;YACvC,MAAMM,iBAAiBF,eACnBG,IAAAA,kCAAgB,EAACP,cAAcf,KAAK,EAAEe,cAAcQ,KAAK,IACzDD,IAAAA,kCAAgB,EAACP,eAAe,OAAOA,kBAAkB,WAAWA,gBAAgB;YACxF,MAAMS,YAAYN,UAAUO,MAAM,CAAC,CAACC,SAAWL,eAAerB,KAAK,KAAK0B,OAAO1B,KAAK;YAEpF,IAAIgB,YAAY;gBACdQ,UAAUG,IAAI,CAACR,eAAe,qBACzBJ,eACAM,kBACDA;YACN;YAEAJ,iBAAiBO;YACjB,OAAOA;QACT;QAEAtB,qBAAAA,+BAAAA,SAAWe;IACb,GAAG;QAACV;KAAS;IAEb,MAAMqB,aAAad,IAAAA,kBAAW,EAAC;QAC7Be,IAAAA,sCAAkB,EAACpB,SAASqB,OAAO,EAAG;IACxC,GAAG;QAACrB;KAAS;IAEb,MAAMsB,YAAYjB,IAAAA,kBAAW,EAC3B,CAACkB,WAAyDnB,aAAamB,UAAU,OACjF;QAACnB;KAAa;IAGhB,MAAMoB,eAAenB,IAAAA,kBAAW,EAAC,CAACkB;QAChCnB,aAAamB,UAAU;IACzB,GAAG;QAACnB;KAAa;IAEjB,MAAMqB,qBAAqBpB,IAAAA,kBAAW,EAAC,CAACqB;QACtC,MAAMZ,QAAQY,gBAAgBC,IAAI;QAElC,IAAI,CAACb,OAAO;YACV;QACF;QAEAQ,UAAUR;QACVK;IACF,GAAG;QAACG;QAAWH;KAAW;IAE1B,MAAMS,cAAcvB,IAAAA,kBAAW,EAAC,CAACwB;QAC/B3B,cAAc2B,MAAMC,aAAa,CAACvC,KAAK;QACvCM,0BAAAA,oCAAAA,cAAgBgC;IAClB,GAAG;QAAChC;KAAc;IAElB,OAAO;QACLN;QACA+B;QACAG;QACAD;QAEAxB;QACAL;QACAE,eAAe+B;QACfT;IACF;AACF"}