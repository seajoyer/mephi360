{"version":3,"sources":["../../../../../src/components/Form/Rating/Rating.tsx"],"sourcesContent":["import { ChangeEvent, ElementType, HTMLAttributes } from 'react';\nimport styles from './Rating.module.css';\n\nimport { clamp } from 'helpers/math';\nimport { useCustomEnsuredControl } from 'hooks/useEnsureControl';\nimport { Icon } from 'types/Icon';\n\nimport { VisuallyHidden } from 'components/Service/VisuallyHidden/VisuallyHidden';\nimport { IconStar } from './icons/star';\n\nexport interface RatingProps extends Omit<HTMLAttributes<HTMLLabelElement>, 'onChange'> {\n  /** The precision of the rating, determining the fraction of the star that can be selected. */\n  precision?: 0.1 | 0.2 | 0.25 | 0.5 | 1;\n  /** The maximum rating value, representing the number of icons displayed. */\n  max?: number;\n  /** The current value of the rating. */\n  value?: number;\n  /** Callback function invoked when the rating value changes. */\n  onChange?: (value: number) => void;\n  /** The component used to render the rating icons. Defaults to a star icon. */\n  IconContainer?: ElementType<Icon>;\n}\n\nconst MINIMUM_PRECISION = 0.1;\n\n/**\n * Renders a customizable rating component, allowing users to provide a rating by selecting a value using icons (e.g., stars).\n * Supports fractional ratings through precision control and allows for custom rating icon components.\n */\nexport const Rating = ({\n  precision = 1,\n  max = 5,\n  onChange,\n  value: valueProp = 0,\n  IconContainer = IconStar,\n}: RatingProps) => {\n  const [value, setValue] = useCustomEnsuredControl({\n    defaultValue: valueProp,\n    onChange,\n  });\n\n  const normalizedPrecision = clamp(precision, MINIMUM_PRECISION, 1);\n\n  const onChangeLabel = (event: ChangeEvent<HTMLLabelElement>) => {\n    const { target } = event;\n    if (target instanceof HTMLInputElement) {\n      setValue(parseFloat(target.value));\n    }\n  };\n\n  const getPickedElementWidth = (elementNumber: number): number | undefined => {\n    if (elementNumber <= value) {\n      return 1;\n    }\n\n    const valueRange = elementNumber - value;\n    if (valueRange > 0 && valueRange < 1) {\n      return 1 - valueRange;\n    }\n\n    return undefined;\n  };\n\n  const keys = Array.from(Array(max).keys());\n  return (\n    <label className={styles.wrapper} onChange={onChangeLabel}>\n      <VisuallyHidden Component=\"input\" name=\"rating\" type=\"radio\" value={0} />\n      {keys.map((key) => {\n        const elementsWithPrecision = Math.floor(1 / normalizedPrecision);\n        const elements = Array.from(Array(elementsWithPrecision).keys());\n\n        const pickedElementWidth = getPickedElementWidth(key + 1);\n        return (\n          <label key={key} className={styles.element}>\n            {pickedElementWidth !== undefined && (\n              <IconContainer\n                key=\"star-picked\"\n                className={styles['element--picked']}\n                style={{ width: `${pickedElementWidth * 100}%` }}\n              />\n            )}\n            <IconContainer key=\"star\" />\n            {elements.map((element) => (\n              <input\n                key={element}\n                type=\"radio\"\n                value={(key + (element + 1) * normalizedPrecision).toFixed(1)}\n                name=\"rating\"\n                style={{\n                  width: `${normalizedPrecision * 100}%`,\n                  left: `${element * normalizedPrecision * 100}%`,\n                }}\n                className={styles.input}\n              />\n            ))}\n          </label>\n        );\n      })}\n    </label>\n  );\n};\n"],"names":["Rating","MINIMUM_PRECISION","precision","max","onChange","value","valueProp","IconContainer","IconStar","setValue","useCustomEnsuredControl","defaultValue","normalizedPrecision","clamp","onChangeLabel","event","target","HTMLInputElement","parseFloat","getPickedElementWidth","elementNumber","valueRange","undefined","keys","Array","from","label","className","VisuallyHidden","Component","name","type","map","key","elementsWithPrecision","Math","floor","elements","pickedElementWidth","style","width","element","input","toFixed","left"],"mappings":";;;;+BA6BaA;;;eAAAA;;;;sBA1BS;kCACkB;gCAGT;sBACN;AAezB,MAAMC,oBAAoB;AAMnB,MAAMD,SAAS,CAAC,EACrBE,YAAY,CAAC,EACbC,MAAM,CAAC,EACPC,QAAQ,EACRC,OAAOC,YAAY,CAAC,EACpBC,gBAAgBC,cAAQ,EACZ;IACZ,MAAM,CAACH,OAAOI,SAAS,GAAGC,IAAAA,yCAAuB,EAAC;QAChDC,cAAcL;QACdF;IACF;IAEA,MAAMQ,sBAAsBC,IAAAA,WAAK,EAACX,WAAWD,mBAAmB;IAEhE,MAAMa,gBAAgB,CAACC;QACrB,MAAM,EAAEC,MAAM,EAAE,GAAGD;QACnB,IAAIC,kBAAkBC,kBAAkB;YACtCR,SAASS,WAAWF,OAAOX,KAAK;QAClC;IACF;IAEA,MAAMc,wBAAwB,CAACC;QAC7B,IAAIA,iBAAiBf,OAAO;YAC1B,OAAO;QACT;QAEA,MAAMgB,aAAaD,gBAAgBf;QACnC,IAAIgB,aAAa,KAAKA,aAAa,GAAG;YACpC,OAAO,IAAIA;QACb;QAEA,OAAOC;IACT;IAEA,MAAMC,OAAOC,MAAMC,IAAI,CAACD,MAAMrB,KAAKoB,IAAI;IACvC,qBACE,sBAACG;QAAMC,SAAS;QAAkBvB,UAAUU;;0BAC1C,qBAACc,8BAAc;gBAACC,WAAU;gBAAQC,MAAK;gBAASC,MAAK;gBAAQ1B,OAAO;;YACnEkB,KAAKS,GAAG,CAAC,CAACC;gBACT,MAAMC,wBAAwBC,KAAKC,KAAK,CAAC,IAAIxB;gBAC7C,MAAMyB,WAAWb,MAAMC,IAAI,CAACD,MAAMU,uBAAuBX,IAAI;gBAE7D,MAAMe,qBAAqBnB,sBAAsBc,MAAM;gBACvD,qBACE,sBAACP;oBAAgBC,SAAS;;wBACvBW,uBAAuBhB,2BACtB,qBAACf;4BAECoB,SAAS;4BACTY,OAAO;gCAAEC,OAAO,CAAC,EAAEF,qBAAqB,IAAI,CAAC,CAAC;4BAAC;2BAF3C;sCAKR,qBAAC/B,mBAAkB;wBAClB8B,SAASL,GAAG,CAAC,CAACS,wBACb,qBAACC;gCAECX,MAAK;gCACL1B,OAAO,AAAC4B,CAAAA,MAAM,AAACQ,CAAAA,UAAU,CAAA,IAAK7B,mBAAkB,EAAG+B,OAAO,CAAC;gCAC3Db,MAAK;gCACLS,OAAO;oCACLC,OAAO,CAAC,EAAE5B,sBAAsB,IAAI,CAAC,CAAC;oCACtCgC,MAAM,CAAC,EAAEH,UAAU7B,sBAAsB,IAAI,CAAC,CAAC;gCACjD;gCACAe,SAAS;+BARJc;;mBAXCR;YAwBhB;;;AAGN"}