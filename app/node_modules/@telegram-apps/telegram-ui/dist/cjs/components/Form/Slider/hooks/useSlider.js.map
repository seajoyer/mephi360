{"version":3,"sources":["../../../../../../src/components/Form/Slider/hooks/useSlider.ts"],"sourcesContent":["'use client';\n\nimport { ChangeEvent, useMemo, useRef, useState } from 'react';\n\nimport { isEqual } from 'helpers/equal';\nimport { clamp } from 'helpers/math';\n\nimport { SliderProps } from 'components/Form/Slider/Slider';\nimport type { TouchEvent } from 'components/Service/Touch/Touch';\nimport { extractSliderAriaAttributes, getDraggingTypeByTargetDataset } from './helpers/html';\nimport { offsetXToScaledValue, toPercent } from './helpers/math';\nimport {\n  determineSnapDirection,\n  isMultipleValues,\n  updateInternalStateByNativeChange,\n  updateInternalStateValue,\n} from './helpers/state';\nimport { InternalGestureRef, InternalValueState, Step } from './types';\n\nexport const useSlider = ({\n  step = 1,\n  min = 0,\n  max = 100,\n  value: valueProp,\n  multiple: multipleProp,\n  defaultValue = multipleProp ? [min, max] : min,\n  disabled,\n  getAriaLabel,\n  getAriaValueText,\n  onChange,\n  ...restProps\n}: SliderProps) => {\n  const isControlled = valueProp !== undefined;\n  const [localValue, setValue] = useState(defaultValue);\n\n  const value = useMemo<InternalValueState>(() => {\n    const resolvedValue = isControlled ? valueProp : localValue;\n\n    return Array.isArray(resolvedValue)\n      ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)]\n      : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n\n  const [startValue, endValue] = value;\n  const multiple = multipleProp && endValue !== null;\n\n  const gesture = useRef<InternalGestureRef>({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0,\n  }).current;\n\n  const thumbsContainerRef = useRef<HTMLDivElement>(null);\n  const thumbStartInputRef = useRef<HTMLInputElement>(null);\n  const thumbEndInputRef = useRef<HTMLInputElement>(null);\n\n  const changeValue = (nextValue: InternalValueState, event: TouchEvent | ChangeEvent) => {\n    if (disabled || isEqual(nextValue[0], nextValue[1])) {\n      return;\n    }\n\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n\n  const handlePointerStart = (event: TouchEvent) => {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n\n    const { left: nextContainerX, width: nextContainerWidth } =\n      thumbsContainerRef.current.getBoundingClientRect();\n\n    if (!(event.originalEvent.target instanceof HTMLElement)) {\n      return;\n    }\n\n    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n    const nextStartX = event.startX - nextContainerX;\n    const nextValue = offsetXToScaledValue(nextStartX, nextContainerWidth, min, max, step);\n    const nextDragging = determineSnapDirection(value, nextValue, foundDraggingType);\n\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n\n    const updatedInternalStateValue = updateInternalStateValue(\n      value,\n      nextValue,\n      min,\n      max,\n      nextDragging,\n    );\n\n    const [nextStartValue, nextEndValue] = updatedInternalStateValue;\n    if (\n      thumbStartInputRef.current &&\n      (foundDraggingType === 'start' || (nextStartValue !== startValue && nextEndValue === endValue))\n    ) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (\n      thumbEndInputRef.current &&\n      (foundDraggingType === 'end' || (nextEndValue !== endValue && nextStartValue === startValue))\n    ) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n\n    changeValue(updatedInternalStateValue, event);\n    event.originalEvent.stopPropagation();\n  };\n\n  const handlePointerMove = (event: TouchEvent) => {\n    const { startX, containerWidth, dragging } = gesture;\n\n    const { shiftX = 0 } = event;\n    const nextStartX = startX + shiftX;\n    const nextValue = offsetXToScaledValue(nextStartX, containerWidth, min, max, step);\n\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const handlePointerEnd = (event: TouchEvent) => {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n  };\n\n  const handleChangeByNativeInput = (event: ChangeEvent<HTMLInputElement>) => {\n    changeValue(\n      updateInternalStateByNativeChange(\n        value,\n        Number(event.target.value),\n        getDraggingTypeByTargetDataset(event.target),\n      ),\n      event,\n    );\n  };\n\n  const { aria, ...restPropsWithoutArea } = extractSliderAriaAttributes(restProps);\n  const getInputProps = (isEndInput: boolean) => {\n    const index = isEndInput ? 1 : 0;\n    return {\n      'data-type': isEndInput ? 'end' : 'start',\n      step,\n      min,\n      value: isEndInput && multiple ? endValue : startValue,\n      max: !isEndInput && multiple ? endValue : max,\n      disabled,\n      'aria-label': getAriaLabel ? getAriaLabel(index) : aria.ariaLabel,\n      'aria-valuetext': getAriaValueText ? getAriaValueText(startValue, index) : aria.ariaValueText,\n      'aria-labelledby': aria.ariaLabelledBy,\n      onChange: handleChangeByNativeInput,\n    };\n  };\n\n  const getStepsCoordinates = () => {\n    if (step === 1) {\n      return undefined;\n    }\n\n    const steps: Step[] = [];\n    const stepsCount = Math.floor((max - min) / step);\n\n    for (let i = 0; i <= stepsCount; i += 1) {\n      const stepValue = min + i * step;\n\n      const isPassed = multiple\n        ? stepValue >= startValue && stepValue <= endValue\n        : stepValue <= startValue;\n\n      steps.push({\n        isPassed,\n        XCoordinate: toPercent(stepValue, min, max),\n      });\n    }\n\n    return steps;\n  };\n\n  return {\n    steps: getStepsCoordinates(),\n    multiple,\n    containerProps: restPropsWithoutArea,\n    startValueInPercent: toPercent(startValue, min, max),\n    endReversedValueInPercent: multiple ? toPercent(endValue, min, max) : 0,\n    thumbsContainerRef,\n    thumbStartInputRef,\n    thumbEndInputRef,\n    handlePointerStart,\n    handlePointerMove,\n    handlePointerEnd,\n    getInputProps,\n  };\n};\n"],"names":["useSlider","step","min","max","value","valueProp","multiple","multipleProp","defaultValue","disabled","getAriaLabel","getAriaValueText","onChange","restProps","isControlled","undefined","localValue","setValue","useState","useMemo","resolvedValue","Array","isArray","clamp","startValue","endValue","gesture","useRef","dragging","startX","containerWidth","current","thumbsContainerRef","thumbStartInputRef","thumbEndInputRef","changeValue","nextValue","event","isEqual","isMultipleValues","handlePointerStart","left","nextContainerX","width","nextContainerWidth","getBoundingClientRect","originalEvent","target","HTMLElement","foundDraggingType","getDraggingTypeByTargetDataset","nextStartX","offsetXToScaledValue","nextDragging","determineSnapDirection","updatedInternalStateValue","updateInternalStateValue","nextStartValue","nextEndValue","focus","preventDefault","stopPropagation","handlePointerMove","shiftX","handlePointerEnd","handleChangeByNativeInput","updateInternalStateByNativeChange","Number","extractSliderAriaAttributes","aria","restPropsWithoutArea","getInputProps","isEndInput","index","ariaLabel","ariaValueText","ariaLabelledBy","getStepsCoordinates","steps","stepsCount","Math","floor","i","stepValue","isPassed","push","XCoordinate","toPercent","containerProps","startValueInPercent","endReversedValueInPercent"],"mappings":"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"}